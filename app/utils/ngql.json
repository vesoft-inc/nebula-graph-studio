[
  {
    "title": "Numeric types",
    "content": "nGQL supports both integer and floating-point number.\nInteger\nSigned 64-bit integer (INT64), 32-bit integer (INT32), 16-bit integer (INT16), and 8-bit integer (INT8) are supported.\nType\nDeclared keywords\nRange\nINT64\nINT64 orINT\n-9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807\nINT32\nINT32\n-2,147,483,648 ~ 2,147,483,647\nINT16\nINT16\n-32,768 ~ 32,767\nINT8\nINT8\n-128 ~ 127\nFloating-point number\nBoth single-precision floating-point format (FLOAT) and double-precision floating-point format (DOUBLE) are supported.\nType\nDeclared keywords\nRange\nPrecision\nFLOAT\nFLOAT\n3.4E +/- 38\n6~7 bits\nDOUBLE\nDOUBLE\n1.7E +/- 308\n15~16 bits\nScientific notation is also supported, such as 1e2, 1.1e2, .3e4, 1.e4, and -1234E-10.\nReading and writing of data values\nWhen writing and reading different types of data, nGQL complies with the following rules:\nData type\nSet as VID\nSet as property\nResulted data type\nINT64\nSupported\nSupported\nINT64\nINT32\nNot supported\nSupported\nINT64\nINT16\nNot supported\nSupported\nINT64\nINT8\nNot supported\nSupported\nINT64\nFLOAT\nNot supported\nSupported\nDOUBLE\nDOUBLE\nNot supported\nSupported\nDOUBLE\nFor example, nGQL does not support setting VID as INT8, but supports setting a certain property type of TAG or Edge type as INT8. When using the nGQL statement to read the property of INT8, the resulted type is INT64.\nMultiple formats are supported:\nDecimal, such as 123456.\nHexadecimal, such as 0x1e240.\nOctal, such as 0361100.\nHowever, NebulaGraph will parse the written non-decimal value into a decimal value and save it. The value read is decimal.\nFor example, the type of the property score is INT. The value of 0xb is assigned to it through the INSERT statement. If querying the property value with statements such as FETCH, you will get the result 11, which is the decimal result of the hexadecimal 0xb.\nRound a FLOAT/DOUBLE value when inserting it to an INT column.",
    "url": "3.data-types/1.numeric/",
    "type": "doc"
  },
  {
    "title": "Boolean",
    "content": "A boolean data type is declared with the bool keyword and can only take the values true or false.\nnGQL supports using boolean in the following ways:\nDefine the data type of the property value as a boolean.\nUse boolean as judgment conditions in the WHERE clause.",
    "url": "3.data-types/2.boolean/",
    "type": "doc"
  },
  {
    "title": "String",
    "content": "Fixed-length strings and variable-length strings are supported.\nDeclaration and literal representation\nThe string type is declared with the keywords of:\nSTRING: Variable-length strings.\nFIXED_STRING(<length>): Fixed-length strings. <length> is the length of the string, such as FIXED_STRING(32).\nA string type is used to store a sequence of characters (text). The literal constant is a sequence of characters of any length surrounded by double or single quotes. For example, \"Hello, Cooper\" or 'Hello, Cooper'.\nString reading and writing\nNebula Graph supports using string types in the following ways:\nDefine the data type of VID as a fixed-length string.\nSet the variable-length string as the Schema name, including the names of the graph space, tag, edge type, and property.\nDefine the data type of the property as a fixed-length or variable-length string.\nFor example:\nDefine the data type of the property as a fixed-length stringnebula> CREATE TAG IF NOT EXISTS t1 (p1 FIXED_STRING(10)); \nDefine the data type of the property as a variable-length stringnebula> CREATE TAG IF NOT EXISTS t2 (p2 STRING); \nWhen the fixed-length string you try to write exceeds the length limit:\nIf the fixed-length string is a property, the writing will succeed, and NebulaGraph will truncate the string and only store the part that meets the length limit.\nIf the fixed-length string is a VID, the writing will fail and NebulaGraph will return an error.\nEscape characters\nLine breaks are not allowed in a string. Escape characters are supported within strings, for example:\n\"\\n\\t\\r\\b\\f\"\n\"\\110ello world\"\nOpenCypher compatibility\nThere are some tiny differences between openCypher and Cypher, as well as nGQL. The following is what openCypher requires. Single quotes cannot be converted to double quotes.\n# File: Literals.feature\nFeature: Literals\nBackground:\n    Given any graph\n Scenario: Return a single-quoted string\n    When executing query:\n      \"\"\"\n      RETURN '' AS literal\n      \"\"\"\n    Then the result should be, in any order:\n      | literal |\n      | ''      |    # Note: it should return single-quotes as openCypher required.\n    And no side effects\nWhile Cypher accepts both single quotes and double quotes as the return results. nGQL follows the Cypher way.\nnebula > YIELD '' AS quote1, \"\" AS quote2, \"'\" AS quote3, '\"' AS quote4",
    "url": "3.data-types/3.string/",
    "type": "doc"
  },
  {
    "title": "Date and time types",
    "content": "This topic will describe the DATE, TIME, DATETIME, TIMESTAMP, and DURATION types.\nPrecautions\nWhile inserting time-type property values with DATE, TIME, and DATETIME, NebulaGraph transforms them to a UTC time according to the timezone specified with the timezone_name parameter in the configuration files. \ndate(), time(), and datetime() can convert a time-type property with a specified timezone. For example, datetime(\"2017-03-04 22:30:40.003000+08:00\") or datetime(\"2017-03-04T22:30:40.003000[Asia/Shanghai]\").\ndate(), time(), datetime(), and timestamp() all accept empty parameters to return the current date, time, and datetime.\ndate(), time(), and datetime() all accept the property name to return a specific property value of itself. For example, date().month returns the current month, while time(\"02:59:40\").minute returns the minutes of the importing time.\nFor time operations it is recommended to use duration() to calculate the offset of the moment. Addition and subtraction of date() and date(), timestamp() and timestamp() are also supported.\nWhen setting the year of the time as a negative number, you need to use Map type data.\nOpenCypher Compatibility\nIn nGQL:\nYear, month, day, hour, minute, second, millisecond, and microsecond are supported, while the nanosecond is not supported.\nlocaldatetime() is not supported.\nMost string time formats are not supported. The exceptions are YYYY-MM-DDThh:mm:ss and YYYY-MM-DD hh:mm:ss.\nThe single-digit string time format is supported. For example, time(\"1:1:1\").\nDATE\nThe DATE type is used for values with a date part but no time part. Nebula Graph retrieves and displays DATE values in the YYYY-MM-DD format. The supported range is -32768-01-01 to 32767-12-31.\nThe properties of date() include year, month, and day. date() supports the input of YYYYY, YYYYY-MM or YYYYY-MM-DD, and defaults to 01 for an untyped month or day.\nnebula> RETURN DATE({year:-123, month:12, day:3});\nnebula> RETURN DATE(\"23333\");\nnebula> RETURN DATE(\"2023-12-12\") - DATE(\"2023-12-11\");\nTIME\nThe TIME type is used for values with a time part but no date part. Nebula Graph retrieves and displays TIME values in hh:mm:ss.msmsmsususus format. The supported range is 00:00:00.000000 to 23:59:59.999999.\nThe properties of time() include hour, minute, and second.\nDATETIME\nThe DATETIME type is used for values that contain both date and time parts. Nebula Graph retrieves and displays DATETIME values in YYYY-MM-DDThh:mm:ss.msmsmsususus format. The supported range is -32768-01-01T00:00:00.000000 to 32767-12-31T23:59:59.999999.\nThe properties of datetime() include year, month, day, hour, minute, and second.\ndatetime() can convert TIMESTAMP to DATETIME. The value range of TIMESTAMP is 0~9223372036.\ndatetime() supports an int argument. The int argument specifies a timestamp.\n# To get the current date and time.\nnebula> RETURN datetime();\n# To get the current hour.\nnebula> RETURN datetime().hour;\n# To get date time from a given timestamp.\nnebula> RETURN datetime(timestamp(1625469277));\nnebula> RETURN datetime(1625469277);\nTIMESTAMP\nThe TIMESTAMP data type is used for values that contain both date and time parts. It has a range of 1970-01-01T00:00:01 UTC to 2262-04-11T23:47:16 UTC.\nTIMESTAMP has the following features:\nStored and displayed in the form of a timestamp, such as 1615974839, which means 2021-03-17T17:53:59.\nSupported TIMESTAMP querying methods: timestamp and timestamp() function.\nSupported TIMESTAMP inserting methods: timestamp, timestamp() function, and now() function.\ntimestamp() function accepts empty arguments to get the current timestamp. It can pass an integer arguments to identify the integer as a timestamp and the range of passed integer is: 0~9223372036。\ntimestamp() function can convert DATETIME to TIMESTAMP, and the data type of DATETIME should be a string. \nThe underlying storage data type is int64.\n# To get the current timestamp.\nnebula> RETURN timestamp();\n# To get a timestamp from given date and time.\nnebula> RETURN timestamp(\"2022-01-05T06:18:43\");\n# To get a timestamp using datetime().\nnebula> RETURN timestamp(datetime(\"2022-08-29T07:53:10.939000\"));\n+---------------------------------------------------+    \nDURATION\nThe DURATION data type is used to indicate a period of time. Map data that are freely combined by years, months, days, hours, minutes, and seconds indicates the DURATION.\nDURATION has the following features:\nCreating indexes for DURATION is not supported.\nDURATION can be used to calculate the specified time.\nExamples\nCreate a tag named date1 with three properties: DATE, TIME, and DATETIME.\nnebula> CREATE TAG IF NOT EXISTS date1(p1 date, p2 time, p3 datetime);\nInsert a vertex named test1.\nnebula> INSERT VERTEX date1(p1, p2, p3) VALUES \"test1\":(date(\"2021-03-17\"), time(\"17:53:59\"), datetime(\"2017-03-04T22:30:40.003000[Asia/Shanghai]\"));\nQuery whether the value of property p1 on the test1 tag is 2021-03-17.\nnebula> MATCH (v:date1)  RETURN v.date1.p1 == date(\"2021-03-17\");\nReturn the content of the property p1 on test1.\nnebula> CREATE TAG INDEX IF NOT EXISTS date1_index ON date1(p1);\nnebula> REBUILD TAG INDEX date1_index;\nnebula> MATCH (v:date1) RETURN v.date1.p1;\nSearch for vertices with p3 property values less than 2023-01-01T00:00:00.000000, and return the p3 values.\nnebula> MATCH (v:date1)  \\\nWHERE v.date1.p3 < datetime(\"2023-01-01T00:00:00.000000\") \\\nRETURN v.date1.p3;\nCreate a tag named school with the property of TIMESTAMP.\nnebula> CREATE TAG IF NOT EXISTS school(name string , found_time timestamp);\nInsert a vertex named DUT with a found-time timestamp of \"1988-03-01T08:00:00\".\n# Insert as a timestamp. The corresponding timestamp of 1988-03-01T08:00:00 is 573177600, or 573206400 UTC.\nnebula> INSERT VERTEX school(name, found_time) VALUES \"DUT\":(\"DUT\", 573206400);\n# Insert in the form of date and time.\nnebula> INSERT VERTEX school(name, found_time) VALUES \"DUT\":(\"DUT\", timestamp(\"1988-03-01T08:00:00\"));\nInsert a vertex named dut and store time with now() or timestamp() functions.\n# Use now() function to store time\nnebula> INSERT VERTEX school(name, found_time) VALUES \"dut\":(\"dut\", now());\n# Use timestamp() function to store time\nnebula> INSERT VERTEX school(name, found_time) VALUES \"dut\":(\"dut\", timestamp());\nYou can also use WITH statement to set a specific date and time, or to perform calculations. For example:\nnebula> WITH time({hour: 12, minute: 31, second: 14, millisecond:111, microsecond: 222}) AS d RETURN d;\nnebula> WITH date({year: 1984, month: 10, day: 11}) AS x RETURN x + 1;\nnebula> WITH date('1984-10-11') as x, duration({years: 12, days: 14, hours: 99, minutes: 12}) as d \\\n        RETURN x + d AS sum, x - d AS diff;",
    "url": "3.data-types/4.date-and-time/",
    "type": "doc"
  },
  {
    "title": "NULL",
    "content": "You can set the properties for vertices or edges to NULL. Also, you can set the NOT NULL constraint to make sure that the property values are NOT NULL. If not specified, the property is set to NULL by default.\nLogical operations with NULL\nHere is the truth table for AND, OR, XOR, and NOT.\na AND b\na OR b\na XOR b\nNOT a\nfalse\nfalse\nfalse\nfalse\nfalse\ntrue\nfalse\nnull\nfalse\nnull\nnull\ntrue\nfalse\ntrue\nfalse\ntrue\ntrue\ntrue\ntrue\nfalse\nfalse\ntrue\ntrue\nfalse\ntrue\nnull\nnull\ntrue\nnull\nfalse\ntrue\ntrue\ntrue\ntrue\nfalse\nfalse\nnull\nfalse\nfalse\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\ntrue\nnull\ntrue\nnull\nnull\nOpenCypher compatibility\nThe comparisons and operations about NULL are different from openCypher. There may be changes later.\nComparisons with NULL\nThe comparison operations with NULL are incompatible with openCypher.\nOperations and RETURN with NULL\nThe NULL operations and RETURN with NULL are incompatible with openCypher.\nExamples\nUse NOT NULL\nCreate a tag named player. Specify the property name as NOT NULL.\nnebula> CREATE TAG IF NOT EXISTS player(name string NOT NULL, age int);\nUse SHOW to create tag statements. The property name is NOT NULL. The property age is NULL by default.\nnebula> SHOW CREATE TAG player;\nInsert the vertex Kobe. The property age can be NULL.\nnebula> INSERT VERTEX player(name, age) VALUES \"Kobe\":(\"Kobe\",null);\nUse NOT NULL and set the default\nCreate a tag named player. Specify the property age as NOT NULL. The default value is 18.\nnebula> CREATE TAG IF NOT EXISTS player(name string, age int NOT NULL DEFAULT 18);\nInsert the vertex Kobe. Specify the property name only.\nnebula> INSERT VERTEX player(name) VALUES \"Kobe\":(\"Kobe\");\nQuery the vertex Kobe. The property age is 18 by default.\nnebula> FETCH PROP ON player \"Kobe\" YIELD properties(vertex);",
    "url": "3.data-types/5.null/",
    "type": "doc"
  },
  {
    "title": "Lists",
    "content": "The list is a composite data type. A list is a sequence of values. Individual elements in a list can be accessed by their positions.\nA list starts with a left square bracket [ and ends with a right square bracket ]. A list contains zero, one, or more expressions. List elements are separated from each other with commas (,). Whitespace around elements is ignored in the list, thus line breaks, tab stops, and blanks can be used for formatting.\nOpenCypher compatibility\nA composite data type (i.e. set, map, and list) CANNOT be stored as properties of vertices or edges.\nList operations\nYou can use the preset list function to operate the list, or use the index to filter the elements in the list.\nIndex syntax\n[M]\n[M..N]\n[M..]\n[..N]\nThe index of nGQL supports queries from front to back, starting from 0. 0 means the first element, 1 means the second element, and so on. It also supports queries from back to front, starting from -1. -1 means the last element, -2 means the penultimate element, and so on.\n[M]: represents the element whose index is M.\n[M..N]: represents the elements whose indexes are greater or equal to M but smaller than N. Return empty when N is 0.\n[M..]: represents the elements whose indexes are greater or equal to M.\n[..N]: represents the elements whose indexes are smaller than N. Return empty when N is 0.\nExamples\n# The following query returns the list [1,2,3].\nnebula> RETURN list[1, 2, 3] AS a;\n# The following query returns the element whose index is 3 in the list [1,2,3,4,5]. In a list, the index starts from 0, and thus the return element is 4.\nnebula> RETURN range(1,5)[3];\n# The following query returns the element whose index is -2 in the list [1,2,3,4,5]. The index of the last element in a list is -1, and thus the return element is 4.\nnebula> RETURN range(1,5)[-2];\n# The following query returns the elements whose indexes are from 0 to 3 (not including 3) in the list [1,2,3,4,5].\nnebula> RETURN range(1,5)[0..3];\n# The following query returns the elements whose indexes are greater than 2 in the list [1,2,3,4,5].\nnebula> RETURN range(1,5)[3..] AS a;\n# The following query returns the elements whose indexes are smaller than 3.\nnebula> WITH list[1, 2, 3, 4, 5] AS a \\\n        RETURN a[..3] AS r;\n# The following query filters the elements whose indexes are greater than 2 in the list [1,2,3,4,5], calculate them respectively, and returns them.\nnebula> RETURN [n IN range(1,5) WHERE n > 2 | n + 10] AS a;\n# The following query returns the elements from the first to the penultimate (inclusive) in the list [1, 2, 3].\nnebula> YIELD list[1, 2, 3][0..-1] AS a;\n# The following query returns the elements from the first (exclusive) to the third backward in the list [1, 2, 3, 4, 5].\nnebula> YIELD list[1, 2, 3, 4, 5][-3..-1] AS a;\n# The following query sets the variables and returns the elements whose indexes are 1 and 2.\nnebula> $var = YIELD 1 AS f, 3 AS t; \\\n        YIELD list[1, 2, 3][$var.f..$var.t] AS a;\n# The following query returns empty because the index is out of bound. It will return normally when the index is within the bound.\nnebula> RETURN list[1, 2, 3, 4, 5] [0..10] AS a;\nnebula> RETURN list[1, 2, 3] [-5..5] AS a;\n# The following query returns empty because there is a [0..0].\nnebula> RETURN list[1, 2, 3, 4, 5] [0..0] AS a;\n# The following query returns empty because of M ≥ N.\nnebula> RETURN list[1, 2, 3, 4, 5] [3..1] AS a;\n# When conduct a range query, if `M` or `N` is null, return `null`.\nnebula> WITH list[1,2,3] AS a \\\n        RETURN a[0..null] as r;\n# The following query calculates the elements in the list [1,2,3,4,5] respectively and returns them without the list head.\nnebula> RETURN tail([n IN range(1, 5) | 2 * n - 10]) AS a;\n# The following query takes the elements in the list [1,2,3] as true and return.\nnebula> RETURN [n IN range(1, 3) WHERE true | n] AS r;\n# The following query returns the length of the list [1,2,3].\nnebula> RETURN size(list[1,2,3]);\n# The following query calculates the elements in the list [92,90] and runs a conditional judgment in a where clause.\nnebula> GO FROM \"player100\" OVER follow WHERE properties(edge).degree NOT IN [x IN [92, 90] | x + $$.player.age] \\\n        YIELD dst(edge) AS id, properties(edge).degree AS degree;\n# The following query takes the query result of the MATCH statement as the elements in a list. Then it calculates and returns them.\nnebula> MATCH p = (n:player{name:\"Tim Duncan\"})-[:follow]->(m) \\\n        RETURN [n IN nodes(p) | n.player.age + 100] AS r;\nOpenCypher compatibility\nIn openCypher, return null when querying a single out-of-bound element. However, in nGQL, return OUT_OF_RANGE when querying a single out-of-bound element.nebula> RETURN range(0,5)[-12];\nA composite data type (i.e., set, map, and list) CAN NOT be stored as properties for vertices or edges.\nIt is recommended to modify the graph modeling method. The composite data type should be modeled as an adjacent edge of a vertex, rather than its property. Each adjacent edge can be dynamically added or deleted. The rank values of the adjacent edges can be used for sequencing.\nPatterns are not supported in the list. For example, [(src)-[]->(m) | m.name].",
    "url": "3.data-types/6.list/",
    "type": "doc"
  },
  {
    "title": "Sets",
    "content": "The set is a composite data type. A set is a set of values. Unlike a List, values in a set are unordered and each value must be unique.\nA set starts with a left curly bracket { and ends with a right curly bracket }. A set contains zero, one, or more expressions. Set elements are separated from each other with commas (,). Whitespace around elements is ignored in the set, thus line breaks, tab stops, and blanks can be used for formatting.\nOpenCypher compatibility\nA composite data type (i.e. set, map, and list) CANNOT be stored as properties of vertices or edges.\nA set is not a data type in openCypher, but in nGQL, users can use the set.\nExamples\n# The following query returns the set {1,2,3}.\nnebula> RETURN set{1, 2, 3} AS a;\n# The following query returns the set {1,2}, Because the set does not allow repeating elements, and the order is unordered.\nnebula> RETURN set{1, 2, 1} AS a;\n# The following query checks whether the set has the specified element 1.\nnebula> RETURN 1 IN set{1, 2} AS a;\n# The following query counts the number of elements in the set.\nnebula> YIELD size(set{1, 2, 1}) AS a;\n# The following query returns a set of target vertex property values.\nnebula> GO FROM \"player100\" OVER follow \\\n        YIELD set{properties($$).name,properties($$).age} as a;",
    "url": "3.data-types/7.set/",
    "type": "doc"
  },
  {
    "title": "Maps",
    "content": "The map is a composite data type. Maps are unordered collections of key-value pairs. In maps, the key is a string. The value can have any data type. You can get the map element by using map['key'].\nA map starts with a left curly bracket { and ends with a right curly bracket }. A map contains zero, one, or more key-value pairs. Map elements are separated from each other with commas (,). Whitespace around elements is ignored in the map, thus line breaks, tab stops, and blanks can be used for formatting.\nOpenCypher compatibility\nA composite data type (i.e. set, map, and list) CANNOT be stored as properties of vertices or edges.\nMap projection is not supported.\nExamples\n# The following query returns the simple map.\nnebula> YIELD map{key1: 'Value1', Key2: 'Value2'} as a;\n# The following query returns the list type map.\nnebula> YIELD map{listKey: [{inner: 'Map1'}, {inner: 'Map2'}]} as a;\n# The following query returns the hybrid type map.\nnebula> RETURN map{a: LIST[1,2], b: SET{1,2,1}, c: \"hee\"} as a;\n# The following query returns the specified element in a map.\nnebula> RETURN map{a: LIST[1,2], b: SET{1,2,1}, c: \"hee\"}[\"b\"] AS b;\n# The following query checks whether the map has the specified key, not support checks whether the map has the specified value yet.\nnebula> RETURN \"a\" IN MAP{a:1, b:2} AS a;",
    "url": "3.data-types/8.map/",
    "type": "doc"
  },
  {
    "title": "Type Conversion/Type coercions",
    "content": "Converting an expression of a given type to another type is known as type conversion.\nNebulaGraph supports converting expressions explicit to other types. For details, see Type conversion functions.\nExamples\nnebula> UNWIND [true, false, 'true', 'false', NULL] AS b \\\n        RETURN toBoolean(b) AS b;\nnebula> RETURN toFloat(1), toFloat('1.3'), toFloat('1e3'), toFloat('not a number');",
    "url": "3.data-types/9.type-conversion/",
    "type": "doc"
  },
  {
    "title": "Geography",
    "content": "Geography is a data type composed of latitude and longitude that represents geospatial information. NebulaGraph currently supports Point, LineString, and Polygon in Simple Features and some functions in SQL-MM 3, such as part of the core geo parsing, construction, formatting, conversion, predicates, and dimensions.\nType description\nA point is the basic data type of geography, which is determined by a latitude and a longitude. For example, \"POINT(3 8)\" means that the longitude is 3° and the latitude is 8°. Multiple points can form a linestring or a polygon.\nShape\nExample\nDescription\nPoint\n\"POINT(3 8)\"\nSpecifies the data type as a point.\nLineString\n\"LINESTRING(3 8, 4.7 73.23)\"\nSpecifies the data type as a linestring.\nPolygon\n\"POLYGON((0 1, 1 2, 2 3, 0 1))\"\nSpecifies the data type as a polygon.\nExamples\n//Create a Tag to allow storing any geography data type.\nnebula> CREATE TAG IF NOT EXISTS any_shape(geo geography);\n//Create a Tag to allow storing a point only.\nnebula> CREATE TAG IF NOT EXISTS only_point(geo geography(point));\n//Create a Tag to allow storing a linestring only.\nnebula> CREATE TAG IF NOT EXISTS only_linestring(geo geography(linestring));\n//Create a Tag to allow storing a polygon only.\nnebula> CREATE TAG IF NOT EXISTS only_polygon(geo geography(polygon));\n//Create an Edge type to allow storing any geography data type.\nnebula> CREATE EDGE IF NOT EXISTS any_shape_edge(geo geography);\n//Create a vertex to store the geography of a polygon.\nnebula> INSERT VERTEX any_shape(geo) VALUES \"103\":(ST_GeogFromText(\"POLYGON((0 1, 1 2, 2 3, 0 1))\"));\n//Create an edge to store the geography of a polygon.\nnebula> INSERT EDGE any_shape_edge(geo) VALUES \"201\"->\"302\":(ST_GeogFromText(\"POLYGON((0 1, 1 2, 2 3, 0 1))\"));\n//Query the geography of Vertex 103.\nnebula> FETCH PROP ON any_shape \"103\" YIELD ST_ASText(any_shape.geo);\n//Query the geography of the edge which traverses from Vertex 201 to Vertex 302.\nnebula> FETCH PROP ON any_shape_edge \"201\"->\"302\" YIELD ST_ASText(any_shape_edge.geo);\n//Create an index for the geography of the Tag any_shape and run LOOKUP.\nnebula> CREATE TAG INDEX IF NOT EXISTS any_shape_geo_index ON any_shape(geo);\nnebula> REBUILD TAG INDEX any_shape_geo_index;\nnebula> LOOKUP ON any_shape YIELD ST_ASText(any_shape.geo);\nWhen creating an index for geography properties, you can specify the parameters for the index.\nParameter\nDefault value\nDescription\ns2_max_level\n30\nThe maximum level of S2 cell used in the covering. Allowed values: 1~30. Setting it to less than the default means that NebulaGraph will be forced to generate coverings using larger cells.\ns2_max_cells\nThe maximum number of S2 cells used in the covering. Provides a limit on how much work is done exploring the possible coverings. Allowed values: 1~30. You may want to use higher values for odd-shaped regions such as skinny rectangles.\nnebula> CREATE TAG INDEX IF NOT EXISTS any_shape_geo_index ON any_shape(geo) with (s2_max_level=30, s2_max_cells=8);",
    "url": "3.data-types/10.geography/",
    "type": "doc"
  },
  {
    "title": "Composite queries (clause structure)",
    "content": "Composite queries put data from different queries together. They then use filters, group-bys, or sorting before returning the combined return results.\nNebula Graph supports three methods to run composite queries (or sub-queries):\n(openCypher) Clauses are chained together, and they feed intermediate result sets between each other.\n(Native nGQL) More than one query can be batched together, separated by semicolons (;). The result of the last query is returned as the result of the batch.\n(Native nGQL) Queries can be piped together by using the pipe (|). The result of the previous query can be used as the input of the next query.\nOpenCypher compatibility\nIn a composite query, do not put together openCypher and native nGQL clauses in one statement. For example, this statement is undefined: MATCH ... | GO ... | YIELD ....\nIf you are in the openCypher way (MATCH, RETURN, WITH, etc), do not introduce any pipe or semicolons to combine the sub-clauses.\nIf you are in the native nGQL way (FETCH, GO, LOOKUP, etc), you must use pipe or semicolons to combine the sub-clauses.\nComposite queries are not transactional queries (as in SQL/Cypher)\nFor example, a query is composed of three sub-queries: A B C, A | B | C or A; B; C. In that A is a read operation, B is a computation operation, and C is a write operation. If any part fails in the execution, the whole result will be undefined. There is no rollback. What is written depends on the query executor.\nExamples\nOpenCypher compatibility statement# Connect multiple queries with clauses.\nnebula> MATCH p=(v:player{name:\"Tim Duncan\"})--() \\\n        WITH nodes(p) AS n \\\n        UNWIND n AS n1 \\\n        RETURN DISTINCT n1;\nNative nGQL (Semicolon queries)# Only return edges.\nnebula> SHOW TAGS; SHOW EDGES;\n# Insert multiple vertices.\nnebula> INSERT VERTEX player(name, age) VALUES \"player100\":(\"Tim Duncan\", 42); \\\n        INSERT VERTEX player(name, age) VALUES \"player101\":(\"Tony Parker\", 36); \\\n        INSERT VERTEX player(name, age) VALUES \"player102\":(\"LaMarcus Aldridge\", 33);\nNative nGQL (Pipe queries)# Connect multiple queries with pipes.\nnebula> GO FROM \"player100\" OVER follow YIELD dst(edge) AS id | \\\n        GO FROM $-.id OVER serve YIELD properties($$).name AS Team, \\\n        properties($^).name AS Player;",
    "url": "4.variable-and-composite-queries/1.composite-queries/",
    "type": "doc"
  },
  {
    "title": "User-defined variables",
    "content": "User-defined variables allow passing the result of one statement to another.\nOpenCypher compatibility\nIn openCypher, when you refer to the vertex, edge, or path of a variable, you need to name it first. For example:\nnebula> MATCH (v:player{name:\"Tim Duncan\"}) RETURN v;\nThe user-defined variable in the preceding query is v.\nNative nGQL\nUser-defined variables are written as $var_name. The var_name consists of letters, numbers, or underline characters. Any other characters are not permitted.\nThe user-defined variables are valid only at the current execution (namely, in this composite query). When the execution ends, the user-defined variables will be automatically expired. The user-defined variables in one statement CANNOT be used in any other clients, executions, or sessions.\nYou can use user-defined variables in composite queries. Details about composite queries, see Composite queries.\nExample\nnebula> $var = GO FROM \"player100\" OVER follow YIELD dst(edge) AS id; \\\n        GO FROM $var.id OVER serve YIELD properties($$).name AS Team, \\\n        properties($^).name AS Player;",
    "url": "4.variable-and-composite-queries/2.user-defined-variables/",
    "type": "doc"
  },
  {
    "title": "Property reference",
    "content": "You can refer to the properties of a vertex or an edge in WHERE and YIELD syntax.\nProperty reference for vertex\nFor source vertex\n$^.<tag_name>.<prop_name>\nParameter\nDescription\n$^\nis used to get the property of the source vertex.\ntag_name\nis the tag name of the vertex.\nprop_name\nspecifies the property name.\nFor destination vertex\n$$.<tag_name>.<prop_name>\nParameter\nDescription\n$$\nis used to get the property of the destination vertex.\ntag_name\nis the tag name of the vertex.\nprop_name\nspecifies the property name.\nProperty reference for edge\nFor user-defined edge property\n<edge_type>.<prop_name>\nParameter\nDescription\nedge_type\nis the edge type of the edge.\nprop_name\nspecifies the property name of the edge type.\nFor built-in properties\nApart from the user-defined edge property, there are four built-in properties in each edge:\nParameter\nDescription\n_src\nsource vertex ID of the edge\n_dst\ndestination vertex ID of the edge\n_type\nedge type\n_rank\nthe rank value for the edge\nExamples\nThe following query returns the name property of the player tag on the source vertex and the age property of the player tag on the destination vertex.\nnebula> GO FROM \"player100\" OVER follow YIELD $^.player.name AS startName, $$.player.age AS endAge;\nThe following query returns the degree property of the edge type follow.\nnebula> GO FROM \"player100\" OVER follow YIELD follow.degree;\nThe following query returns the source vertex, the destination vertex, the edge type, and the edge rank value of the edge type follow.\nnebula> GO FROM \"player100\" OVER follow YIELD follow._src, follow._dst, follow._type, follow._rank;",
    "url": "4.variable-and-composite-queries/3.property-reference/",
    "type": "doc"
  },
  {
    "title": "Comparison operators",
    "content": "NebulaGraph supports the following comparison operators.\nName\nDescription\n==\nEqual operator\n!=, <>\nNot equal operator\nGreater than operator\n>=\nGreater than or equal operator\nLess than operator\n<=\nLess than or equal operator\nIS NULL\nNULL check\nIS NOT NULL\nNot NULL check\nIS EMPTY\nEMPTY check\nIS NOT EMPTY\nNot EMPTY check\nThe result of the comparison operation is true or false.\nOpenCypher compatibility\nopenCypher does not have EMPTY. Thus EMPTY is not supported in MATCH statements.\nExamples\n==\nString comparisons are case-sensitive. Values of different types are not equal.\nnebula> RETURN 'A' == 'a', toUpper('A') == toUpper('a'), toLower('A') == toLower('a');\nnebula> RETURN '2' == 2, toInteger('2') == 2;\nnebula> RETURN 3 > 2;\nnebula> WITH 4 AS one, 3 AS two \\\n        RETURN one > two AS result;\n>=\nnebula> RETURN 2 >= \"2\", 2 >= 2;\nnebula> YIELD 2.0 < 1.9;\n<=\nnebula> YIELD 0.11 <= 0.11;\n!=\nnebula> YIELD 1 != '1';\nIS [NOT] NULL\nnebula> RETURN null IS NULL AS value1, null == null AS value2, null != null AS value3;\nnebula> RETURN length(NULL), size(NULL), count(NULL), NULL IS NULL, NULL IS NOT NULL, sin(NULL), NULL + NULL, [1, NULL] IS NULL;\nnebula> WITH {name: null} AS `map` \\\n        RETURN `map`.name IS NOT NULL;\nnebula> WITH {name: 'Mats', name2: 'Pontus'} AS map1, \\\n        {name: null} AS map2, {notName: 0, notName2: null } AS map3 \\\n        RETURN map1.name IS NULL, map2.name IS NOT NULL, map3.name IS NULL;\nnebula> MATCH (n:player) \\\n        RETURN n.player.age IS NULL, n.player.name IS NOT NULL, n.player.empty IS NULL;\n...\nIS [NOT] EMPTY\nnebula> RETURN null IS EMPTY;\nnebula> RETURN \"a\" IS NOT EMPTY;\nnebula> GO FROM \"player100\" OVER * WHERE properties($$).name IS NOT EMPTY YIELD dst(edge);",
    "url": "5.operators/1.comparison/",
    "type": "doc"
  },
  {
    "title": "Boolean operators",
    "content": "NebulaGraph supports the following boolean operators.\nName\nDescription\nAND\nLogical AND\nNOT\nLogical NOT\nOR\nLogical OR\nXOR\nLogical XOR\nFor the precedence of the operators, refer to Operator Precedence.\nFor the logical operations with NULL, refer to NULL.\nLegacy version compatibility\nNon-zero numbers cannot be converted to boolean values.",
    "url": "5.operators/2.boolean/",
    "type": "doc"
  },
  {
    "title": "Pipe operators",
    "content": "Multiple queries can be combined using pipe operators in nGQL.\nOpenCypher compatibility\nPipe operators apply to native nGQL only.\nSyntax\nOne major difference between nGQL and SQL is how sub-queries are composed.\nIn SQL, sub-queries are nested in the query statements.\nIn nGQL, the shell style PIPE (|) is introduced into the sub-queries.\nExamples\nnebula> GO FROM \"player100\" OVER follow \\\n        YIELD dst(edge) AS dstid, properties($$).name AS Name | \\\n        GO FROM $-.dstid OVER follow YIELD dst(edge);\nUsers must define aliases in the YIELD clause for the reference operator $- to use, just like $-.dstid in the preceding example.\nPerformance tips\nIn NebulaGraph, pipes will affect the performance. Take A | B as an example, the effects are as follows:\nPipe operators operate synchronously. That is, the data can enter the pipe clause as a whole after the execution of clause A before the pipe operator is completed.\nPipe operators need to be serialized and deserialized, which is executed in a single thread.\nIf A sends a large amount of data to |, the entire query request may be very slow. You can try to split this statement.\nSend A from the application,\nSplit the return results on the application,\nSend to multiple graphd processes concurrently,\nEvery graphd process executes part of B.\nThis is usually much faster than executing a complete A | B with a single graphd process.",
    "url": "5.operators/4.pipe/",
    "type": "doc"
  },
  {
    "title": "Reference operators",
    "content": "NGQL provides reference operators to represent a property in a WHERE or YIELD clause, or the output of the statement before the pipe operator in a composite query.\nOpenCypher compatibility\nReference operators apply to native nGQL only.\nReference operator List\nReference operator\nDescription\n$^\nRefers to a source vertex property. For more information, see Property reference.\n$$\nRefers to a destination vertex property. For more information, see Property reference.\n$-\nRefers to the output of the statement before the pipe operator in a composite query. For more information, see Pipe.\nExamples\n# The following example returns the age of the source vertex and the destination vertex.\nnebula> GO FROM \"player100\" OVER follow YIELD properties($^).age AS SrcAge, properties($$).age AS DestAge;\n# The following example returns the name and team of the players that player100 follows.\nnebula> GO FROM \"player100\" OVER follow \\\n        YIELD dst(edge) AS id | \\\n        GO FROM $-.id OVER serve \\\n        YIELD $^.player.name AS Player, properties($$).name AS Team;",
    "url": "5.operators/5.property-reference/",
    "type": "doc"
  },
  {
    "title": "Set operators",
    "content": "This topic will describe the set operators, including UNION, UNION ALL, INTERSECT, and MINUS. To combine multiple queries, use these set operators.\nAll set operators have equal precedence. If a nGQL statement contains multiple set operators, NebulaGraph will evaluate them from left to right unless parentheses explicitly specify another order.\nUNION, UNION DISTINCT, and UNION ALL\n<left> UNION [DISTINCT | ALL] <right> [ UNION [DISTINCT | ALL] <right> ...]\nOperator UNION DISTINCT (or by short UNION) returns the union of two sets A and B without duplicated elements.\nOperator UNION ALL returns the union of two sets A and B with duplicated elements.\nThe <left> and <right> must have the same number of columns and data types. Different data types are converted according to the Type Conversion.\nExamples\n# The following statement returns the union of two query results without duplicated elements.\nnebula> GO FROM \"player102\" OVER follow YIELD dst(edge) \\\n        UNION \\\n        GO FROM \"player100\" OVER follow YIELD dst(edge);\nnebula> MATCH (v:player) \\\n        WITH v.player.name AS v \\\n        RETURN n ORDER BY n LIMIT 3 \\\n        UNION \\\n        UNWIND [\"Tony Parker\", \"Ben Simmons\"] AS n \\\n        RETURN n;\n# The following statement returns the union of two query results with duplicated elements.\nnebula> GO FROM \"player102\" OVER follow YIELD dst(edge) \\\n        UNION ALL \\\n        GO FROM \"player100\" OVER follow YIELD dst(edge);\nnebula> MATCH (v:player) \\\n        WITH v.player.name AS n \\\n        RETURN n ORDER BY n LIMIT 3 \\\n        UNION ALL \\\n        UNWIND [\"Tony Parker\", \"Ben Simmons\"] AS n \\\n        RETURN n;\n# UNION can also work with the YIELD statement. The DISTINCT keyword will check duplication by all the columns for every line, and remove duplicated lines if every column is the same.\nnebula> GO FROM \"player102\" OVER follow \\\n        YIELD dst(edge) AS id, properties(edge).degree AS Degree, properties($$).age AS Age \\\n        UNION /* DISTINCT */ \\\n        GO FROM \"player100\" OVER follow \\\n        YIELD dst(edge) AS id, properties(edge).degree AS Degree, properties($$).age AS Age;\nINTERSECT\n<left> INTERSECT <right>\nOperator INTERSECT returns the intersection of two sets A and B (denoted by A ⋂ B).\nSimilar to UNION, the left and right must have the same number of columns and data types. Different data types are converted according to the Type Conversion.\nExample\n# The following statement returns the intersection of two query results.\nnebula> GO FROM \"player102\" OVER follow \\\n        YIELD dst(edge) AS id, properties(edge).degree AS Degree, properties($$).age AS Age \\\n        INTERSECT \\\n        GO FROM \"player100\" OVER follow \\\n        YIELD dst(edge) AS id, properties(edge).degree AS Degree, properties($$).age AS Age;\nnebula> MATCH (v:player)-[e:follow]->(v2) \\\n        WHERE id(v) == \"player102\" \\\n        RETURN id(v2) As id, e.degree As Degree, v2.player.age AS Age \\\n        INTERSECT \\\n        MATCH (v:player)-[e:follow]->(v2) \\\n        WHERE id(v) == \"player100\" \\\n        RETURN id(v2) As id, e.degree As Degree, v2.player.age AS Age;\nnebula> UNWIND [1,2] AS a RETURN a \\\n        INTERSECT \\\n        UNWIND [1,2,3,4] AS a \\\n        RETURN a;\nMINUS\n<left> MINUS <right>\nOperator MINUS returns the subtraction (or difference) of two sets A and B (denoted by A-B). Always pay attention to the order of left and right. The set A-B consists of elements that are in A but not in B.\nExample\n# The following statement returns the elements in the first query result but not in the second query result.\nnebula> GO FROM \"player100\" OVER follow YIELD dst(edge) \\\n        MINUS \\\n        GO FROM \"player102\" OVER follow YIELD dst(edge);\nnebula> GO FROM \"player102\" OVER follow YIELD dst(edge) AS id\\\n        MINUS \\\n        GO FROM \"player100\" OVER follow YIELD dst(edge) AS id;\nnebula> MATCH (v:player)-[e:follow]->(v2) \\\n        WHERE id(v) ==\"player102\" \\\n        RETURN id(v2) AS id\\\n        MINUS \\\n        MATCH (v:player)-[e:follow]->(v2) \\\n        WHERE id(v) ==\"player100\" \\\n        RETURN id(v2) AS id;\nnebula> UNWIND [1,2,3] AS a RETURN a \\\n        MINUS \\\n        WITH 4 AS a \\\n        RETURN a;\nPrecedence of the set operators and pipe operators\nPlease note that when a query contains a pipe | and a set operator, the pipe takes precedence. Refer to Pipe for details. The query GO FROM 1 UNION GO FROM 2 | GO FROM 3 is the same as the query GO FROM 1 UNION (GO FROM 2 | GO FROM 3).\nExamples\nnebula> GO FROM \"player102\" OVER follow \\\n        YIELD dst(edge) AS play_dst  \\\n        UNION \\\n        GO FROM \"team200\" OVER serve REVERSELY \\\n        YIELD src(edge) AS play_src \\\n        | GO FROM $-.play_src OVER follow YIELD dst(edge) AS play_dst;\nThe above query executes the statements in the red bar first and then executes the statement in the green box.\nThe parentheses can change the execution priority. For example:\nnebula> (GO FROM \"player102\" OVER follow \\\n        YIELD dst(edge) AS play_dst  \\\n        UNION \\\n        GO FROM \"team200\" OVER serve REVERSELY \\\n        YIELD src(edge) AS play_dst) \\\n        | GO FROM $-.play_dst OVER follow YIELD dst(edge) AS play_dst;\nIn the above query, the statements within the parentheses take precedence. That is, the UNION operation will be executed first, and its output will be executed as the input of the next operation with pipes.",
    "url": "5.operators/6.set/",
    "type": "doc"
  },
  {
    "title": "String operators",
    "content": "You can use the following string operators for concatenating, querying, and matching.\nName\nDescription\nConcatenates strings.\nCONTAINS\nPerforms searchings in strings.\n(NOT) IN\nChecks whether a value is within a set of values.\n(NOT) STARTS WITH\nPerforms matchings at the beginning of a string.\n(NOT) ENDS WITH\nPerforms matchings at the end of a string.\nRegular expressions\nPerform string matchings using regular expressions.\nExamples\nnebula> RETURN 'a' + 'b';\nnebula> UNWIND 'a' AS a UNWIND 'b' AS b RETURN a + b;\nCONTAINS\nThe CONTAINS operator requires string types on both left and right sides.\nnebula> MATCH (s:player)-[e:serve]->(t:team) WHERE id(s) == \"player101\" \\\n        AND t.team.name CONTAINS \"ets\" RETURN s.player.name, e.start_year, e.end_year, t.team.name;\nnebula> GO FROM \"player101\" OVER serve WHERE (STRING)properties(edge).start_year CONTAINS \"19\" AND \\\n        properties($^).name CONTAINS \"ny\" \\\n        YIELD properties($^).name, properties(edge).start_year, properties(edge).end_year, properties($$).name;\nnebula> GO FROM \"player101\" OVER serve WHERE !(properties($$).name CONTAINS \"ets\") \\\n        YIELD properties($^).name, properties(edge).start_year, properties(edge).end_year, properties($$).name;\n(NOT) IN\nnebula> RETURN  1 IN [1,2,3], \"Yao\" NOT IN [\"Yi\", \"Tim\", \"Kobe\"], NULL IN [\"Yi\", \"Tim\", \"Kobe\"];\n(NOT) STARTS WITH\nnebula> RETURN 'apple' STARTS WITH 'app', 'apple' STARTS WITH 'a', 'apple' STARTS WITH toUpper('a');\nnebula> RETURN 'apple' STARTS WITH 'b','apple' NOT STARTS WITH 'app';\n(NOT) ENDS WITH\nnebula> RETURN 'apple' ENDS WITH 'app', 'apple' ENDS WITH 'e', 'apple' ENDS WITH 'E', 'apple' ENDS WITH 'b';\nRegular expressions\nNebulaGraph supports filtering by using regular expressions. The regular expression syntax is inherited from std::regex. You can match on regular expressions by using =~ 'regexp'. For example:\nnebula> RETURN \"384748.39\" =~ \"\\\\d+(\\\\.\\\\d{2})?\";\nnebula> MATCH (v:player) WHERE v.player.name =~ 'Tony.*' RETURN v.player.name;",
    "url": "5.operators/7.string/",
    "type": "doc"
  },
  {
    "title": "List operators",
    "content": "NebulaGraph supports the following list operators:\nList operator\nDescription\nConcatenates lists.\nIN\nChecks if an element exists in a list.\n[]\nAccesses an element(s) in a list using the index operator.\nExamples\nnebula> YIELD [1,2,3,4,5]+[6,7] AS myList;\nnebula> RETURN size([NULL, 1, 2]);\nnebula> RETURN NULL IN [NULL, 1];\nnebula> WITH [2, 3, 4, 5] AS numberlist \\\n    UNWIND numberlist AS number \\\n    WITH number \\\n    WHERE number IN [2, 3, 8] \\\n    RETURN number;\nnebula> WITH ['Anne', 'John', 'Bill', 'Diane', 'Eve'] AS names RETURN names[1] AS result;",
    "url": "5.operators/8.list/",
    "type": "doc"
  },
  {
    "title": "Arithmetic operators",
    "content": "NebulaGraph supports the following arithmetic operators.\nName\nDescription\nAddition operator\nMinus operator\nMultiplication operator\nDivision operator\nModulo operator\nChanges the sign of the argument\nExamples\nnebula> RETURN 1+2 AS result;\nnebula> RETURN -10+5 AS result;\nnebula> RETURN (3*8)%5 AS result;",
    "url": "5.operators/10.arithmetic/",
    "type": "doc"
  },
  {
    "title": "Operator precedence",
    "content": "The following list shows the precedence of nGQL operators in descending order. Operators that are shown together on a line have the same precedence.\n- (negative number)\n!, NOT\n*, /, %\n-, +\n==, >=, >, <=, <, <>, !=\nAND\nOR, XOR\n= (assignment)\nFor operators that occur at the same precedence level within an expression, evaluation proceeds left to right, with the exception that assignments evaluate right to left.\nThe precedence of operators determines the order of evaluation of terms in an expression. To modify this order and group terms explicitly, use parentheses.\nExamples\nnebula> RETURN 2+3*5;\nnebula> RETURN (2+3)*5;\nOpenCypher compatibility\nIn openCypher, comparisons can be chained arbitrarily, e.g., x < y <= z is equivalent to x < y AND y <= z in openCypher.\nBut in nGQL, x < y <= z is equivalent to (x < y) <= z. The result of (x < y) is a boolean. Compare it with an integer z, and you will get the final result NULL.",
    "url": "5.operators/9.precedence/",
    "type": "doc"
  },
  {
    "title": "Built-in math functions",
    "content": "This topic describes the built-in math functions supported by NebulaGraph.\nabs()\nabs() returns the absolute value of the argument.\nSyntax: abs(<expression>)\nexpression: An expression of which the result type is double.\nResult type: Double\nExample:\nnebula> RETURN abs(-10);\nnebula> RETURN abs(5-6);\nfloor()\nfloor() returns the largest integer value smaller than or equal to the argument.(Rounds down)\nSyntax: floor(<expression>)\nexpression: An expression of which the result type is double.\nResult type: Double\nExample:\nnebula> RETURN floor(9.9);\nceil()\nceil() returns the smallest integer greater than or equal to the argument.(Rounds up)\nSyntax: ceil(<expression>)\nexpression: An expression of which the result type is double.\nResult type: Double\nExample:\nnebula> RETURN ceil(9.1);\nround()\nround() returns the rounded value of the specified number. Pay attention to the floating-point precision when using this function.\nSyntax: round(<expression>, <digit>)\nexpression: An expression of which the result type is double.\ndigit: Decimal digits. If digit is less than 0, round at the left of the decimal point.\nResult type: Double\nExample:\nnebula> RETURN round(314.15926, 2);\nnebula> RETURN round(314.15926, -1);\nsqrt()\nsqrt() returns the square root of the argument.\nSyntax: sqrt(<expression>)\nexpression: An expression of which the result type is double.\nResult type: Double\nExample:\nnebula> RETURN sqrt(9);\ncbrt()\ncbrt() returns the cubic root of the argument.\nSyntax: cbrt(<expression>)\nexpression: An expression of which the result type is double.\nResult type: Double\nExample:\nnebula> RETURN cbrt(8);\nhypot()\nhypot() returns the hypotenuse of a right-angled triangle.\nSyntax: hypot(<expression_x>,<expression_y>)\nexpression_x, expression_y: An expression of which the result type is double. They represent the side lengths x and y of a right triangle.\nResult type: Double\nExample:\nnebula> RETURN hypot(3,2*2);\npow()\npow() returns the result of xy.\nSyntax: pow(<expression_x>,<expression_y>,)\nexpression_x: An expression of which the result type is double. It represents the base x.\nexpression_y: An expression of which the result type is double. It represents the exponential y.\nResult type: Double\nExample:\nnebula> RETURN pow(3,3);\nexp()\nexp() returns the result of ex.\nSyntax: exp(<expression>)\nexpression: An expression of which the result type is double. It represents the exponential x.\nResult type: Double\nExample:\nnebula> RETURN exp(2);\nexp2()\nexp2() returns the result of 2x.\nSyntax: exp2(<expression>)\nexpression: An expression of which the result type is double. It represents the exponential x.\nResult type: Double\nExample:\nnebula> RETURN exp2(3);\nlog()\nlog() returns the base-e logarithm of the argument. (\\(log_{e}{N}\\))\nSyntax: log(<expression>)\nexpression: An expression of which the result type is double. It represents the antilogarithm N.\nResult type: Double\nExample:\nnebula> RETURN log(8);\nlog2()\nlog2() returns the base-2 logarithm of the argument. (\\(log_{2}{N}\\))\nSyntax: log2(<expression>)\nexpression: An expression of which the result type is double. It represents the antilogarithm N.\nResult type: Double\nExample:\nnebula> RETURN log2(8);\nlog10()\nlog10() returns the base-10 logarithm of the argument. (\\(log_{10}{N}\\))\nSyntax: log10(<expression>)\nexpression: An expression of which the result type is double. It represents the antilogarithm N.\nResult type: Double\nExample:\nnebula> RETURN log10(100);\nsin()\nsin() returns the sine of the argument. Users can convert angles to radians using the function radians().\nSyntax: sin(<expression>)\nexpression: An expression of which the result type is double.\nResult type: Double\nExample:\nnebula> RETURN sin(3);\nasin()\nasin() returns the inverse sine of the argument. Users can convert angles to radians using the function radians().\nSyntax: asin(<expression>)\nexpression: An expression of which the result type is double.\nResult type: Double\nExample:\nnebula> RETURN asin(0.5);\ncos()\ncos() returns the cosine of the argument. Users can convert angles to radians using the function radians().\nSyntax: cos(<expression>)\nexpression: An expression of which the result type is double.\nResult type: Double\nExample:\nnebula> RETURN cos(0.5);\nacos()\nacos() returns the inverse cosine of the argument. Users can convert angles to radians using the function radians().\nSyntax: acos(<expression>)\nexpression: An expression of which the result type is double.\nResult type: Double\nExample:\nnebula> RETURN acos(0.5);\ntan()\ntan() returns the tangent of the argument. Users can convert angles to radians using the function radians().\nSyntax: tan(<expression>)\nexpression: An expression of which the result type is double.\nResult type: Double\nExample:\nnebula> RETURN tan(0.5);\natan()\natan() returns the inverse tangent of the argument. Users can convert angles to radians using the function radians().\nSyntax: atan(<expression>)\nexpression: An expression of which the result type is double.\nResult type: Double\nExample:\nnebula> RETURN atan(0.5);\nrand()\nrand() returns a random floating point number in the range from 0 (inclusive) to 1 (exclusive); i.e.[0,1).\nSyntax: rand()\nResult type: Double\nExample:\nnebula> RETURN rand();\nrand32()\nrand32() returns a random 32-bit integer in [min, max).\nSyntax: rand32(<expression_min>,<expression_max>)\nexpression_min: An expression of which the result type is int. It represents the minimum min.\nexpression_max: An expression of which the result type is int. It represents the maximum max.\nResult type: Int\nIf you set only one argument, it is parsed as max and min is 0 by default. If you set no argument, the system returns a random signed 32-bit integer.\nExample:\nnebula> RETURN rand32(1,100);\nrand64()\nrand64() returns a random 64-bit integer in [min, max).\nSyntax: rand64(<expression_min>,<expression_max>)\nexpression_min: An expression of which the result type is int. It represents the minimum min.\nexpression_max: An expression of which the result type is int. It represents the maximum max.\nResult type: Int\nIf you set only one argument, it is parsed as max and min is 0 by default. If you set no argument, the system returns a random signed 64-bit integer.\nExample:\nnebula> RETURN rand64(1,100);\nbit_and()\nbit_and() returns the result of bitwise AND.\nSyntax: bit_and(<expression_1>,<expression_2>)\nexpression_1, expression_2: An expression of which the result type is int.\nResult type: Int\nExample:\nnebula> RETURN bit_and(5,6);\nbit_or()\nbit_or() returns the result of bitwise OR.\nSyntax: bit_or(<expression_1>,<expression_2>)\nexpression_1, expression_2: An expression of which the result type is int.\nResult type: Int\nExample:\nnebula> RETURN bit_or(5,6);\nbit_xor()\nbit_xor() returns the result of bitwise XOR.\nSyntax: bit_xor(<expression_1>,<expression_2>)\nexpression_1, expression_2: An expression of which the result type is int.\nResult type: Int\nExample:\nnebula> RETURN bit_xor(5,6);\nsize()\nsize() returns the number of elements in a list or a map, or the length of a string.\nSyntax: size({<expression>|<string>})\nexpression: An expression for a list or map.\nstring: A specified string.\nResult type: Int\nExample:\nnebula> RETURN size([1,2,3,4]);\nnebula> RETURN size(\"basketballplayer\") as size;\nrange()\nrange() returns a list of integers from [start,end] in the specified steps.\nSyntax: range(<expression_start>,<expression_end>[,<expression_step>])\nexpression_start: An expression of which the result type is int. It represents the starting value start.\nexpression_end: An expression of which the result type is int. It represents the end value end.\nexpression_step: An expression of which the result type is int. It represents the step size step, step is 1 by default.\nResult type: List\nExample:\nnebula> RETURN range(1,3*3,2);\nsign()\nsign() returns the signum of the given number. If the number is 0, the system returns 0. If the number is negative, the system returns -1. If the number is positive, the system returns 1.\nSyntax: sign(<expression>)\nexpression: An expression of which the result type is double.\nResult type: Int\nExample:\nnebula> RETURN sign(10);\ne()\ne() returns the base of the natural logarithm, e (2.718281828459045).\nSyntax: e()\nResult type: Double\nExample:\nnebula> RETURN e();\npi()\npi() returns the mathematical constant pi (3.141592653589793).\nSyntax: pi()\nResult type: Double\nExample:\nnebula> RETURN pi();\nradians()\nradians() converts angles to radians.\nSyntax: radians(<angle>)\nResult type: Double\nExample:\nnebula> RETURN radians(180);",
    "url": "6.functions-and-expressions/1.math/",
    "type": "doc"
  },
  {
    "title": "Aggregating functions",
    "content": "This topic describes the aggregating functions supported by NebulaGraph.\navg()\navg() returns the average value of the argument.\nSyntax: avg(<expression>)\nResult type: Double\nExample:\nnebula> MATCH (v:player) RETURN avg(v.player.age);\ncount()\ncount() returns the number of records.\n(Native nGQL) You can use count() and GROUP BY together to group and count the number of parameters. Use YIELD to return.\n(OpenCypher style) You can use count() and RETURN. GROUP BY is not necessary.\nSyntax: count({<expression> | *})\ncount(*) returns the number of rows (including NULL).\nResult type: Int\nExample:\nnebula> WITH [NULL, 1, 1, 2, 2] As a UNWIND a AS b \\\n        RETURN count(b), count(*), count(DISTINCT b);\n# The statement in the following example searches for the people whom `player101` follows and people who follow `player101`, i.e. a bidirectional query.\n# Group and count the number of parameters.\nnebula> GO FROM \"player101\" OVER follow BIDIRECT \\\n        YIELD properties($$).name AS Name \\\n        | GROUP BY $-.Name YIELD $-.Name, count(*);\n# Count the number of parameters.\nnebula> MATCH (v1:player)-[:follow]-(v2:player) \\\n        WHERE id(v1)== \"player101\" \\\n        RETURN v2.player.name AS Name, count(*) as cnt ORDER BY cnt DESC;\nThe preceding example retrieves two columns:\n$-.Name: the names of the people.\ncount(*): how many times the names show up.\nBecause there are no duplicate names in the basketballplayer dataset, the number 2 in the column count(*) shows that the person in that row and player101 have followed each other.\n# a: The statement in the following example retrieves the age distribution of the players in the dataset.\nnebula> LOOKUP ON player \\\n        YIELD player.age As playerage \\\n        | GROUP BY $-.playerage \\\n        YIELD $-.playerage as age, count(*) AS number \\\n        | ORDER BY $-.number DESC, $-.age DESC;\n...\n# b: The statement in the following example retrieves the age distribution of the players in the dataset.\nnebula> MATCH (n:player) \\\n        RETURN n.player.age as age, count(*) as number \\\n        ORDER BY number DESC, age DESC;\n...\n# The statement in the following example counts the number of edges that Tim Duncan relates.\nnebula> MATCH (v:player{name:\"Tim Duncan\"}) -[e]- (v2) \\\n        RETURN count(e);\n# The statement in the following example counts the number of edges that Tim Duncan relates and returns two columns (no DISTINCT and DISTINCT) in multi-hop queries.\nnebula> MATCH (n:player {name : \"Tim Duncan\"})-[]->(friend:player)-[]->(fof:player) \\\n        RETURN count(fof), count(DISTINCT fof);\nmax()\nmax() returns the maximum value.\nSyntax: max(<expression>)\nResult type: Same as the original argument.\nExample:\nnebula> MATCH (v:player) RETURN max(v.player.age);\nmin()\nmin() returns the minimum value.\nSyntax: min(<expression>)\nResult type: Same as the original argument.\nExample:\nnebula> MATCH (v:player) RETURN min(v.player.age);\ncollect()\ncollect() returns a list containing the values returned by an expression. Using this function aggregates data by merging multiple records or values into a single list.\nSyntax: collect(<expression>)\nResult type: List\nExample:\nnebula> UNWIND [1, 2, 1] AS a \\\n        RETURN a;\nnebula> UNWIND [1, 2, 1] AS a \\\n        RETURN collect(a);\nnebula> UNWIND [1, 2, 1] AS a \\\n        RETURN a, collect(a), size(collect(a));\n# The following examples sort the results in descending order, limit output rows to 3, and collect the output into a list.\nnebula> UNWIND [\"c\", \"b\", \"a\", \"d\" ] AS p \\\n        WITH p AS q \\\n        ORDER BY q DESC LIMIT 3 \\\n        RETURN collect(q);\nnebula> WITH [1, 1, 2, 2] AS coll \\\n        UNWIND coll AS x \\\n        WITH DISTINCT x \\\n        RETURN collect(x) AS ss;\nnebula> MATCH (n:player) \\\n        RETURN collect(n.player.age);\n| [32, 32, 34, 29, 41, 40, 33, 25, 40, 37, ...\n...\n# The following example aggregates all the players' names by their ages.\nnebula> MATCH (n:player) \\\n        RETURN n.player.age AS age, collect(n.player.name);\n...\nnebula> GO FROM \"player100\" OVER serve \\\n        YIELD properties($$).name AS name \\\n        | GROUP BY $-.name \\\n        YIELD collect($-.name) AS name;\nnebula> LOOKUP ON player \\\n        YIELD player.age As playerage \\\n        | GROUP BY $-.playerage \\\n        YIELD collect($-.playerage) AS playerage;\n...\nstd()\nstd() returns the population standard deviation.\nSyntax: std(<expression>)\nResult type: Double\nExample:\nnebula> MATCH (v:player) RETURN std(v.player.age);\nsum()\nsum() returns the sum value.\nSyntax: sum(<expression>)\nResult type: Same as the original argument.\nExample:\nnebula> MATCH (v:player) RETURN sum(v.player.age);\nAggregating example\nnebula>  GO FROM \"player100\" OVER follow YIELD dst(edge) AS dst, properties($$).age AS age \\\n         | GROUP BY $-.dst \\\n         YIELD \\\n         $-.dst AS dst, \\\n         toInteger((sum($-.age)/count($-.age)))+avg(distinct $-.age+1)+1 AS statistics;",
    "url": "6.functions-and-expressions/15.aggregating/",
    "type": "doc"
  },
  {
    "title": "Built-in string functions",
    "content": "This topic describes the built-in string functions supported by NebulaGraph.\nPrecautions\nA string type is used to store a sequence of characters (text). The literal constant is a sequence of characters of any length surrounded by double or single quotes.\nLike SQL, the position index of nGQL starts from 1, while in C language it starts from 0.\nstrcasecmp()\nstrcasecmp() compares string a and b without case sensitivity.\nSyntax: strcasecmp(<string_a>,<string_b>)\nstring_a, string_b: Strings to compare.\nResult type: Int\nWhen string_a = string_b, the return value is 0. When string_a > string_b, the return value is greater than 0. When string_a < string_b, the return value is less than 0.\nExample:\nnebula> RETURN strcasecmp(\"a\",\"aa\");\nlower() and toLower()\nlower() and toLower() can both returns the argument in lowercase.\nSyntax: lower(<string>), toLower(<string>)\nstring: A specified string.\nResult type: String\nExample:\nnebula> RETURN lower(\"Basketball_Player\");\nupper() and toUpper()\nupper() and toUpper() can both returns the argument in uppercase.\nSyntax: upper(<string>), toUpper(<string>)\nstring: A specified string.\nResult type: String\nExample:\nnebula> RETURN upper(\"Basketball_Player\");\nlength()\nlength() returns the length of the given string in bytes.\nSyntax: length({<string>|<path>})\nstring: A specified string.\npath: A specified path represented by a variable.\nResult type: Int\nExample:\nnebula> RETURN length(\"basketball\");\nnebula> MATCH p=(v:player{name:\"Tim Duncan\"})-->(v2) return length(p);\ntrim()\ntrim() removes the spaces at the leading and trailing of the string.\nSyntax: trim(<string>)\nstring: A specified string.\nResult type: String\nExample:\nnebula> RETURN trim(\" basketball player \");\nltrim()\nltrim() removes the spaces at the leading of the string.\nSyntax: ltrim(<string>)\nstring: A specified string.\nResult type: String\nExample:\nnebula> RETURN ltrim(\" basketball player \");\nrtrim()\nrtrim() removes the spaces at the trailing of the string.\nSyntax: rtrim(<string>)\nstring: A specified string.\nResult type: String\nExample:\nnebula> RETURN rtrim(\" basketball player \");\nleft()\nleft() returns a substring consisting of several characters from the leading of a string.\nSyntax: left(<string>,<count>)\nstring: A specified string.\ncount: The number of characters from the leading of the string. If the string is shorter than count, the system returns the string itself.\nResult type: String\nExample:\nnebula> RETURN left(\"basketball_player\",6);\nright()\nright() returns a substring consisting of several characters from the trailing of a string.\nSyntax: right(<string>,<count>)\nstring: A specified string.\ncount: The number of characters from the trailing of the string. If the string is shorter than count, the system returns the string itself.\nResult type: String\nExample:\nnebula> RETURN right(\"basketball_player\",6);\nlpad()\nlpad() pads a specified string from the left-side to the specified length and returns the result string.\nSyntax: lpad(<string>,<count>,<letters>)\nstring: A specified string.\ncount: The length of the string after it has been left-padded. If the length is less than that of string, only the length of string characters from front to back will be returned.\nletters: A string to be padding from the leading.\nResult type: String\nExample:\nnebula> RETURN lpad(\"abcd\",10,\"b\");\nnebula> RETURN lpad(\"abcd\",3,\"b\");\nrpad()\nrpad() pads a specified string from the right-side to the specified length and returns the result string.\nSyntax: rpad(<string>,<count>,<letters>)\nstring: A specified string.\ncount: The length of the string after it has been right-padded. If the length is less than that of string, only the length of string characters from front to back will be returned.\nletters: A string to be padding from the trailing.\nResult type: String\nExample:\nnebula> RETURN rpad(\"abcd\",10,\"b\");\nnebula> RETURN rpad(\"abcd\",3,\"b\");\nsubstr() and substring()\nsubstr() and substring() return a substring extracting count characters starting from the specified position pos of a specified string.\nSyntax: substr(<string>,<pos>,<count>), substring(<string>,<pos>,<count>)\nstring: A specified string.\npos: The position of starting extract (character index). Data type is int.\ncount: The number of characters extracted from the start position onwards.\nResult type: String\nExplanations for the return of substr() and substring()\nIf pos is 0, it extracts from the specified string leading (including the first character).\nIf pos is greater than the maximum string index, an empty string is returned.\nIf pos is a negative number, BAD_DATA is returned.\nIf count is omitted, the function returns the substring starting at the position given by pos and extending to the end of the string.\nIf count is 0, an empty string is returned.\nUsing NULL as any of the argument of substr() will cause an issue.\nExample:\nnebula> RETURN substr(\"abcdefg\",2,4);\nnebula> RETURN substr(\"abcdefg\",0,4);\nnebula> RETURN substr(\"abcdefg\",2);\nreverse()\nreverse() returns a string in reverse order.\nSyntax: reverse(<string>)\nstring: A specified string.\nResult type: String\nExample:\nnebula> RETURN reverse(\"abcdefg\");\nreplace()\nreplace() replaces string a in a specified string with string b.\nSyntax: replace(<string>,<substr_a>,<string_b>)\nstring: A specified string.\nsubstr_a: String a.\nstring_b: String b.\nResult type: String\nExample:\nnebula> RETURN replace(\"abcdefg\",\"cd\",\"AAAAA\");\nsplit()\nsplit() splits a specified string at string b and returns a list of strings.\nSyntax: split(<string>,<substr>)\nstring: A specified string.\nsubstr: String b.\nResult type: List\nExample:\nnebula> RETURN split(\"basketballplayer\",\"a\");\nconcat()\nconcat() returns strings concatenated by all strings.\nSyntax: concat(<string1>,<string2>,...)\nThe function requires at least two or more strings. If there is only one string, the string itself is returned.\nIf any one of the strings is NULL, NULL is returned.\nResult type: String\nExample:\n//This example concatenates 1, 2, and 3.\nnebula> RETURN concat(\"1\",\"2\",\"3\") AS r;\n//In this example, one of the string is NULL.\nnebula> RETURN concat(\"1\",\"2\",NULL) AS r;\nnebula> GO FROM \"player100\" over follow \\\n        YIELD concat(src(edge), properties($^).age, properties($$).name, properties(edge).degree) AS A;\nconcat_ws()\nconcat_ws() returns strings concatenated by all strings that are delimited with a separator.\nSyntax: concat_ws(<separator>,<string1>,<string2>,... )\nThe function requires at least two or more strings.\nIf the separator is NULL, the concat_ws() function returns NULL.\nIf the separator is not NULL and there is only one string, the string itself is returned.\nIf there is a NULL in the strings, NULL is ignored during the concatenation.\nExample:\n//This example concatenates a, b, and c with the separator +.\nnebula> RETURN concat_ws(\"+\",\"a\",\"b\",\"c\") AS r;\n//In this example, the separator is NULL.\nneubla> RETURN concat_ws(NULL,\"a\",\"b\",\"c\") AS r;\n//In this example, the separator is + and there is a NULL in the strings.\nnebula> RETURN concat_ws(\"+\",\"a\",NULL,\"b\",\"c\") AS r;\n//In this example, the separator is + and there is only one string.\nnebula> RETURN concat_ws(\"+\",\"a\") AS r;\nnebula> GO FROM \"player100\" over follow \\\n        YIELD concat_ws(\" \",src(edge), properties($^).age, properties($$).name, properties(edge).degree) AS A;\nextract()\nextract() uses regular expression matching to retrieve a single substring or all substrings from a string.\nSyntax: extract(<string>,\"<regular_expression>\")\nstring: A specified string\nregular_expression: A regular expression\nResult type: List\nExample:\nnebula> MATCH (a:player)-[b:serve]-(c:team{name: \"Lakers\"}) \\\n        WHERE a.player.age > 45 \\\n        RETURN extract(a.player.name, \"\\\\w+\") AS result;\nnebula> MATCH (a:player)-[b:serve]-(c:team{name: \"Lakers\"}) \\\n        WHERE a.player.age > 45 \\\n        RETURN extract(a.player.name, \"hello\") AS result;\njson_extract()\njson_extract() converts the specified JSON string to a map.\nSyntax: extract(<string>)\nstring:A specified string, must be JSON string.\nResult type: Map\nExample:\nnebula> YIELD json_extract('{\"a\": 1, \"b\": {}, \"c\": {\"d\": true}}') AS result;",
    "url": "6.functions-and-expressions/2.string/",
    "type": "doc"
  },
  {
    "title": "Built-in date and time functions",
    "content": "NebulaGraph supports the following built-in date and time functions:\nFunction\nDescription\nint now()\nReturns the current timestamp of the system.\ntimestamp timestamp()\nReturns the current timestamp of the system.\ndate date()\nReturns the current UTC date based on the current system.\ntime time()\nReturns the current UTC time based on the current system.\ndatetime datetime()\nReturns the current UTC date and time based on the current system.\nmap duration()\nReturns the period of time. It can be used to calculate the specified time.\nFor more information, see Date and time types.\nExamples\nnebula>  RETURN now(), timestamp(), date(), time(), datetime();",
    "url": "6.functions-and-expressions/3.date-and-time/",
    "type": "doc"
  },
  {
    "title": "Schema-related functions",
    "content": "This topic describes the schema-related functions supported by NebulaGraph. There are two types of schema-related functions, one for native nGQL statements and the other for openCypher-compatible statements.\nFor nGQL statements\nThe following functions are available in YIELD and WHERE clauses of nGQL statements.\nid(vertex)\nid(vertex) returns the ID of a vertex.\nSyntax: id(vertex)\nResult type: Same as the vertex ID.\nExample:\nnebula> LOOKUP ON player WHERE player.age  > 45 YIELD id(vertex);\nproperties(vertex)\nproperties(vertex) returns the properties of a vertex.\nSyntax: properties(vertex)\nResult type: Map\nExample:\nnebula> LOOKUP ON player WHERE player.age  > 45 \\\n        YIELD properties(vertex);\nYou can also use the property reference symbols ($^ and $$) instead of the vertex field in the properties() function to get all properties of a vertex.\n$^ represents the data of the starting vertex at the beginning of exploration. For example, in GO FROM \"player100\" OVER follow reversely YIELD properties($^), $^ refers to the vertex player100.\n$$ represents the data of the end vertex at the end of exploration.\nproperties($^) and properties($$) are generally used in GO statements. For more information, see Property reference.\nproperties(edge)\nproperties(edge) returns the properties of an edge.\nSyntax: properties(edge)\nResult type: Map\nExample:\nnebula> GO FROM \"player100\" OVER follow \\\n        YIELD properties(edge);\ntype(edge)\ntype(edge) returns the edge type of an edge.\nSyntax: type(edge)\nResult type: String\nExample:\nnebula> GO FROM \"player100\" OVER follow \\\n        YIELD src(edge), dst(edge), type(edge), rank(edge);\nsrc(edge)\nsrc(edge) returns the source vertex ID of an edge.\nSyntax: src(edge)\nResult type: Same as the vertex ID.\nExample:\nnebula> GO FROM \"player100\" OVER follow \\\n        YIELD src(edge), dst(edge);\ndst(edge)\ndst(edge) returns the destination vertex ID of an edge.\nSyntax: dst(edge)\nResult type: Same as the vertex ID.\nExample:\nnebula> GO FROM \"player100\" OVER follow \\\n        YIELD src(edge), dst(edge);\nrank(edge)\nrank(edge) returns the rank value of an edge.\nSyntax: rank(edge)\nResult type: Int\nExample:\nnebula> GO FROM \"player100\" OVER follow \\\n        YIELD src(edge), dst(edge), rank(edge);\nvertex\nvertex returns the information of vertices, including VIDs, tags, properties, and values. You need to use AS <alias> to set the alias.\nSyntax: vertex\nExample:\nnebula> LOOKUP ON player WHERE player.age > 45 YIELD vertex AS v;\nedge\nedge returns the information of edges, including edge types, source vertices, destination vertices, ranks, properties, and values. You need to use AS <alias> to set the alias.\nSyntax: edge\nExample:\nnebula> GO FROM \"player100\" OVER follow YIELD edge AS e;\nvertices\nvertices returns the information of vertices in a subgraph. For more information, see GET SUBGRAPH.\nedges\nedges returns the information of edges in a subgraph. For more information, see GET SUBGRAPH.\npath\npath returns the information of a path. For more information, see FIND PATH.\nFor statements compatible with openCypher\nThe following functions are available in RETURN and WHERE clauses of openCypher-compatible statements.\nid()\nid() returns the ID of a vertex.\nSyntax: id(<vertex>)\nResult type: Same as the vertex ID.\nExample:\nnebula> MATCH (v:player) RETURN id(v); \n...\ntags() and labels()\ntags() and labels() return the Tag of a vertex.\nSyntax: tags(<vertex>), labels(<vertex>)\nResult type: List\nExample:\nnebula> MATCH (v) WHERE id(v) == \"player100\" \\\n        RETURN tags(v);\nproperties()\nproperties() returns the properties of a vertex or an edge.\nSyntax: properties(<vertex_or_edge>)\nResult type: Map\nExample:\nnebula> MATCH (v:player)-[e:follow]-() RETURN properties(v),properties(e);\n...\ntype()\ntype() returns the edge type of an edge.\nSyntax: type(<edge>)\nResult type: String\nExample:\nnebula> MATCH (v:player{name:\"Tim Duncan\"})-[e]->() \\\n        RETURN type(e);\nsrc()\nsrc() returns the source vertex ID of an edge.\nSyntax: src(<edge>)\nResult type: Same as the vertex ID.\nExample:\nnebula> MATCH ()-[e]->(v:player{name:\"Tim Duncan\"}) \\\n        RETURN src(e);\n...\ndst()\ndst() returns the destination vertex ID of an edge.\nSyntax: dst(<edge>)\nResult type: Same as the vertex ID.\nExample:\nnebula> MATCH (v:player{name:\"Tim Duncan\"})-[e]->() \\\n        RETURN dst(e);\nstartNode()\nstartNode() visits a path and returns its information of source vertex ID, including VIDs, tags, properties, and values.\nSyntax: startNode(<path>)\nExample:\nnebula> MATCH p = (a :player {name : \"Tim Duncan\"})-[r:serve]-(t) \\\n        RETURN startNode(p);\nendNode()\nendNode() visits a path and returns its information of destination vertex ID, including VIDs, tags, properties, and values.\nSyntax: endNode(<path>)\nExample:\nnebula> MATCH p = (a :player {name : \"Tim Duncan\"})-[r:serve]-(t) \\\n        RETURN endNode(p);\nrank()\nrank() returns the rank value of an edge.\nSyntax: rank(<edge>)\nResult type: Int\nExample:\nnebula> MATCH (v:player{name:\"Tim Duncan\"})-[e]->() \\\n        RETURN rank(e);",
    "url": "6.functions-and-expressions/4.schema/",
    "type": "doc"
  },
  {
    "title": "List functions",
    "content": "This topic describes the list functions supported by NebulaGraph. Some of the functions have different syntax in native nGQL statements and openCypher-compatible statements.\nPrecautions\nLike SQL, the position index in nGQL starts from 1, while in the C language it starts from 0.\nGeneral\nrange()\nrange() returns the list containing all the fixed-length steps in [start,end].\nSyntax: range(start, end [, step])\nstep: Optional parameters. step is 1 by default.\nResult type: List\nExample:\nnebula> RETURN range(1,9,2);\nreverse()\nreverse() returns the list reversing the order of all elements in the original list.\nSyntax: reverse(<list>)\nResult type: List\nExample:\nnebula> WITH [NULL, 4923, 'abc', 521, 487] AS ids \\\n        RETURN reverse(ids);\ntail()\ntail() returns all the elements of the original list, excluding the first one.\nSyntax: tail(<list>)\nResult type: List\nExample:\nnebula> WITH [NULL, 4923, 'abc', 521, 487] AS ids \\\n        RETURN tail(ids);\nhead()\nhead() returns the first element of a list.\nSyntax: head(<list>)\nResult type: Same as the element in the original list.\nExample:\nnebula> WITH [NULL, 4923, 'abc', 521, 487] AS ids \\\n        RETURN head(ids);\nlast()\nlast() returns the last element of a list.\nSyntax: last(<list>)\nResult type: Same as the element in the original list.\nExample:\nnebula> WITH [NULL, 4923, 'abc', 521, 487] AS ids \\\n        RETURN last(ids);\nreduce()\nreduce() applies an expression to each element in a list one by one, chains the result to the next iteration by taking it as the initial value, and returns the final result. This function iterates each element e in the given list, runs the expression on e, accumulates the result with the initial value, and store the new result in the accumulator as the initial value of the next iteration. It works like the fold or reduce method in functional languages such as Lisp and Scala.\nSyntax: reduce(<accumulator> = <initial>, <variable> IN <list> | <expression>)\naccumulator: A variable that will hold the accumulated results as the list is iterated.\ninitial: An expression that runs once to give an initial value to the accumulator.\nvariable: A variable in the list that will be applied to the expression successively.\nlist: A list or a list of expressions.\nexpression: This expression will be run on each element in the list once and store the result value in the accumulator.\nResult type: Depends on the parameters provided, along with the semantics of the expression.\nExample:\nnebula> RETURN reduce(totalNum = -4 * 5, n IN [1, 2] | totalNum + n * 2) AS r;\nnebula> MATCH p = (n:player{name:\"LeBron James\"})<-[:follow]-(m) \\\n        RETURN  nodes(p)[0].player.age AS src1,  nodes(p)[1].player.age AS dst2,  \\\n        reduce(totalAge = 100, n IN nodes(p) | totalAge + n.player.age) AS sum;\nnebula> LOOKUP ON player WHERE player.name == \"Tony Parker\" YIELD id(vertex) AS VertexID \\\n        |  GO FROM $-.VertexID over follow \\\n        WHERE properties(edge).degree != reduce(totalNum = 5, n IN range(1, 3) | properties($$).age + totalNum + n) \\\n        YIELD properties($$).name AS id, properties($$).age AS age, properties(edge).degree AS degree;\nFor nGQL statements\nkeys()\nkeys() returns a list containing the string representations for all the property names of vertices or edges.\nSyntax: keys({vertex | edge})\nResult type: List\nExample:\nnebula> LOOKUP ON player \\\n        WHERE player.age  > 45 \\\n        YIELD keys(vertex);\nlabels()\nlabels() returns the list containing all the tags of a vertex.\nSyntax: labels(verte)\nResult type: List\nExample:\nnebula> FETCH PROP ON * \"player101\", \"player102\", \"team204\" \\\n        YIELD labels(vertex);\nFor statements compatible with openCypher\nkeys()\nkeys() returns a list containing the string representations for all the property names of vertices, edges, or maps.\nSyntax: keys(<vertex_or_edge>)\nResult type: List\nExample:\nnebula> MATCH (v:player{name:\"Tim Duncan\"})-[e]->() \\\n        RETURN keys(e);\nlabels()\nlabels() returns the list containing all the tags of a vertex.\nSyntax: labels(<vertex>)\nResult type: List\nExample:\nnebula> MATCH (v)-[e:serve]->() \\\n        WHERE id(v)==\"player100\" \\\n        RETURN labels(v);\nnodes()\nnodes() returns the list containing all the vertices in a path.\nSyntax: nodes(<path>)\nResult type: List\nExample:\nnebula> MATCH p=(v:player{name:\"Tim Duncan\"})-->(v2) \\\n        RETURN nodes(p);\nrelationships()\nrelationships() returns the list containing all the relationships in a path.\nSyntax: relationships(<path>)\nResult type: List\nExample:\nnebula> MATCH p=(v:player{name:\"Tim Duncan\"})-->(v2) \\\n        RETURN relationships(p);",
    "url": "6.functions-and-expressions/6.list/",
    "type": "doc"
  },
  {
    "title": "Type conversion functions",
    "content": "This topic describes the type conversion functions supported by NebulaGraph.\ntoBoolean()\ntoBoolean() converts a string value to a boolean value.\nSyntax: toBoolean(<value>)\nResult type: Bool\nExample:\nnebula> UNWIND [true, false, 'true', 'false', NULL] AS b \\\n        RETURN toBoolean(b) AS b;\ntoFloat()\ntoFloat() converts an integer or string value to a floating point number.\nSyntax: toFloat(<value>)\nResult type: Float\nExample:\nnebula> RETURN toFloat(1), toFloat('1.3'), toFloat('1e3'), toFloat('not a number');\ntoString()\ntoString() converts non-compound types of data, such as numbers, booleans, and so on, to strings.\nSyntax: toString(<value>)\nResult type: String\nExample:\nnebula> RETURN toString(9669) AS int2str, toString(null) AS null2str;\ntoInteger()\ntoInteger() converts a floating point or string value to an integer value.\nSyntax: toInteger(<value>)\nResult type: Int\nExample:\nnebula> RETURN toInteger(1), toInteger('1'), toInteger('1e3'), toInteger('not a number');\ntoSet()\ntoSet() converts a list or set value to a set value.\nSyntax: toSet(<value>)\nResult type: Set\nExample:\nnebula> RETURN toSet(list[1,2,3,1,2]) AS list2set;\nhash()\nhash() returns the hash value of the argument. The argument can be a number, a string, a list, a boolean, null, or an expression that evaluates to a value of the preceding data types.\nThe source code of the hash() function (MurmurHash2), seed (0xc70f6907UL), and other parameters can be found in MurmurHash2.h.\nFor Java, the hash function operates as follows.\nMurmurHash2.hash64(\"to_be_hashed\".getBytes(),\"to_be_hashed\".getBytes().length, 0xc70f6907)\nSyntax: hash(<string>)\nResult type: Int\nExample:\nnebula> RETURN hash(\"abcde\");\nnebula> YIELD hash([1,2,3]);\nnebula> YIELD hash(NULL);\nnebula> YIELD hash(toLower(\"HELLO NEBULA\"));",
    "url": "6.functions-and-expressions/16.type-conversion/",
    "type": "doc"
  },
  {
    "title": "Conditional expressions",
    "content": "This topic describes the conditional functions supported by NebulaGraph.\nCASE\nThe CASE expression uses conditions to filter the parameters. nGQL provides two forms of CASE expressions just like openCypher: the simple form and the generic form.\nThe CASE expression will traverse all the conditions. When the first condition is met, the CASE expression stops reading the conditions and returns the result. If no conditions are met, it returns the result in the ELSE clause. If there is no ELSE clause and no conditions are met, it returns NULL.\nThe simple form of CASE expressions\nSyntax\nCASE <comparer>\nWHEN <value> THEN <result>\n[WHEN ...]\n[ELSE <default>]\nEND\nParameter\nDescription\ncomparer\nA value or a valid expression that outputs a value. This value is used to compare with the value.\nvalue\nIt will be compared with the comparer. If the value matches the comparer, then this condition is met.\nresult\nThe result is returned by the CASE expression if the value matches the comparer.\ndefault\nThe default is returned by the CASE expression if no conditions are met.\nExamples\nnebula> RETURN \\\n        CASE 2+3 \\\n        WHEN 4 THEN 0 \\\n        WHEN 5 THEN 1 \\\n        ELSE -1 \\\n        END \\\n        AS result;\nnebula> GO FROM \"player100\" OVER follow \\\n        YIELD properties($$).name AS Name, \\\n        CASE properties($$).age > 35 \\\n        WHEN true THEN \"Yes\" \\\n        WHEN false THEN \"No\" \\\n        ELSE \"Nah\" \\\n        END \\\n        AS Age_above_35;\nThe generic form of CASE expressions\nSyntax\nCASE\nWHEN <condition> THEN <result>\n[WHEN ...]\n[ELSE <default>]\nEND\nParameter\nDescription\ncondition\nIf the condition is evaluated as true, the result is returned by the CASE expression.\nresult\nThe result is returned by the CASE expression if the condition is evaluated as true.\ndefault\nThe default is returned by the CASE expression if no conditions are met.\nExamples\nnebula> YIELD \\\n        CASE WHEN 4 > 5 THEN 0 \\\n        WHEN 3+4==7 THEN 1 \\\n        ELSE 2 \\\n        END \\\n        AS result;\nnebula> MATCH (v:player) WHERE v.player.age > 30 \\\n        RETURN v.player.name AS Name,  \\\n        CASE \\\n        WHEN v.player.name STARTS WITH \"T\" THEN \"Yes\" \\\n        ELSE \"No\" \\\n        END \\\n        AS Starts_with_T;\nDifferences between the simple form and the generic form\nTo avoid the misuse of the simple form and the generic form, it is important to understand their differences. The following example can help explain them.\nnebula> GO FROM \"player100\" OVER follow \\\n        YIELD properties($$).name AS Name, properties($$).age AS Age, \\\n        CASE properties($$).age \\\n        WHEN properties($$).age > 35 THEN \"Yes\" \\\n        ELSE \"No\" \\\n        END \\\n        AS Age_above_35;\nThe preceding GO query is intended to output Yes when the player's age is above 35. However, in this example, when the player's age is 36, the actual output is not as expected: It is No instead of Yes.\nThis is because the query uses the CASE expression in the simple form, and a comparison between the values of $$.player.age and $$.player.age > 35 is made. When the player age is 36:\nThe value of $$.player.age is 36. It is an integer.\n$$.player.age > 35 is evaluated to be true. It is a boolean.\nThe values of $$.player.age and $$.player.age > 35 do not match. Therefore, the condition is not met and No is returned.\ncoalesce()\ncoalesce() returns the first not null value in all expressions.\nSyntax: coalesce(<expression_1>[,<expression_2>...])\nResult type: Same as the original element.\nExample:\nnebula> RETURN coalesce(null,[1,2,3]) as result;\nnebula> RETURN coalesce(null) as result;",
    "url": "6.functions-and-expressions/5.conditional-expressions/",
    "type": "doc"
  },
  {
    "title": "Predicate functions",
    "content": "Predicate functions return true or false. They are most commonly used in WHERE clauses.\nNebulaGraph supports the following predicate functions:\nFunctions\nDescription\nexists()\nReturns true if the specified property exists in the vertex, edge or map. Otherwise, returns false.\nany()\nReturns true if the specified predicate holds for at least one element in the given list. Otherwise, returns false.\nall()\nReturns true if the specified predicate holds for all elements in the given list. Otherwise, returns false.\nnone()\nReturns true if the specified predicate holds for no element in the given list. Otherwise, returns false.\nsingle()\nReturns true if the specified predicate holds for exactly one of the elements in the given list. Otherwise, returns false.\nSyntax\n<predicate>(<variable> IN <list> WHERE <condition>)\nExamples\nnebula> RETURN any(n IN [1, 2, 3, 4, 5, NULL] \\\n        WHERE n > 2) AS r;\nnebula> RETURN single(n IN range(1, 5) \\\n        WHERE n == 3) AS r;\nnebula> RETURN none(n IN range(1, 3) \\\n        WHERE n == 0) AS r;\nnebula> WITH [1, 2, 3, 4, 5, NULL] AS a \\\n        RETURN any(n IN a WHERE n > 2);\nnebula> MATCH p = (n:player{name:\"LeBron James\"})<-[:follow]-(m) \\\n        RETURN nodes(p)[0].player.name AS n1, nodes(p)[1].player.name AS n2, \\\n        all(n IN nodes(p) WHERE n.player.name NOT STARTS WITH \"D\") AS b;\nnebula> MATCH p = (n:player{name:\"LeBron James\"})-[:follow]->(m) \\\n        RETURN single(n IN nodes(p) WHERE n.player.age > 40) AS b;\nnebula> MATCH (n:player) \\\n        RETURN exists(n.player.id), n IS NOT NULL;\n...\nnebula> MATCH (n:player) \\\n        WHERE exists(n['name']) RETURN n;\n...",
    "url": "6.functions-and-expressions/8.predicate/",
    "type": "doc"
  },
  {
    "title": "Geography functions",
    "content": "Geography functions are used to generate or perform operations on the value of the geography data type.\nFor descriptions of the geography data types, see Geography.\nDescriptions\nFunction\nReturn Type\nDescription\nST_Point(longitude, latitude)\nGEOGRAPHY\nCreates the geography that contains a point.\nST_GeogFromText(wkt_string)\nGEOGRAPHY\nReturns the geography corresponding to the input WKT string.\nST_ASText(geography)\nSTRING\nReturns the WKT string of the input geography.\nST_Centroid(geography)\nGEOGRAPHY\nReturns the centroid of the input geography in the form of the single point geography.\nST_ISValid(geography)\nBOOL\nReturns whether the input geography is valid.\nST_Intersects(geography_1, geography_2)\nBOOL\nReturns whether geography_1 and geography_2 have intersections.\nST_Covers(geography_1, geography_2)\nBOOL\nReturns whether geography_1 completely contains geography_2. If there is no point outside geography_1 in geography_2, return True.\nST_CoveredBy(geography_1, geography_2)\nBOOL\nReturns whether geography_2 completely contains geography_1.If there is no point outside geography_2 in geography_1, return True.\nST_DWithin(geography_1, geography_2, distance)\nBOOL\nIf the distance between one point (at least) in geography_1 and one point in geography_2 is less than or equal to the distance specified by the distance parameter (measured by meters), return True.\nST_Distance(geography_1, geography_2)\nFLOAT\nReturns the smallest possible distance (measured by meters) between two non-empty geographies.\nS2_CellIdFromPoint(point_geography)\nINT\nReturns the S2 Cell ID that covers the point geography.\nS2_CoveringCellIds(geography)\nARRAY<INT64>\nReturns an array of S2 Cell IDs that cover the input geography.\nExamples\nnebula> RETURN ST_ASText(ST_Point(1,1));\nnebula> RETURN ST_ASText(ST_GeogFromText(\"POINT(3 8)\"));\nnebula> RETURN ST_ASTEXT(ST_Centroid(ST_GeogFromText(\"LineString(0 1,1 0)\")));\nnebula> RETURN ST_ISValid(ST_GeogFromText(\"POINT(3 8)\"));\nnebula> RETURN ST_Intersects(ST_GeogFromText(\"LineString(0 1,1 0)\"),ST_GeogFromText(\"LineString(0 0,1 1)\"));\nnebula> RETURN ST_Covers(ST_GeogFromText(\"POLYGON((0 0,10 0,10 10,0 10,0 0))\"),ST_Point(1,2));\nnebula> RETURN ST_CoveredBy(ST_Point(1,2),ST_GeogFromText(\"POLYGON((0 0,10 0,10 10,0 10,0 0))\"));\nnebula> RETURN ST_dwithin(ST_GeogFromText(\"Point(0 0)\"),ST_GeogFromText(\"Point(10 10)\"),20000000000.0);\nnebula> RETURN ST_Distance(ST_GeogFromText(\"Point(0 0)\"),ST_GeogFromText(\"Point(10 10)\"));\nnebula> RETURN S2_CellIdFromPoint(ST_GeogFromText(\"Point(1 1)\"));\nnebula> RETURN S2_CoveringCellIds(ST_GeogFromText(\"POLYGON((0 1, 1 2, 2 3, 0 1))\"));",
    "url": "6.functions-and-expressions/14.geo/",
    "type": "doc"
  },
  {
    "title": "MATCH",
    "content": "The MATCH statement provides pattern-based search functionality, allowing you to retrieve data that matches one or more patterns in NebulaGraph. By defining one or more patterns, you can search for data that matches the patterns in NebulaGraph. Once the matching data is retrieved, you can use the RETURN clause to return it as a result.\nThe examples in this topic use the basketballplayer dataset as the sample dataset.\nSyntax\nThe syntax of MATCH is relatively more flexible compared with that of other query statements such as GO or LOOKUP. The path type of the MATCH statement is trail. That is, only vertices can be repeatedly visited in the graph traversal. Edges cannot be repeatedly visited. For details, see path. But generally, it can be summarized as follows.\nMATCH <pattern> [<clause_1>] RETURN <output> [<clause_2>];\npattern: The MATCH statement supports matching one or multiple patterns. Multiple patterns are separated by commas (,). For example: (a)-[]->(b),(c)-[]->(d). For the detailed description of patterns, see Patterns. \nclause_1: The WHERE, WITH, UNWIND, and OPTIONAL MATCH clauses are supported, and the MATCH clause can also be used.\noutput: Define the list name for the output results to be returned. You can use AS to set an alias for the list.\nclause_2: The ORDER BY and LIMIT clauses are supported.\nNotes\nAvoid full table scans, as they may result in decreased query performance, and if there is insufficient memory during a full table scan, the query may fail, and the system will report an error. It is recommended to use queries with filter conditions or specifying tags and edge types, such as v:player and v.player.name in the statement MATCH (v:player) RETURN v.player.name AS Name.\nYou can create an index for a tag, edge type, or a specific property of a tag or edge type to improve query performance. For example, you can create an index for the player tag or the name property of the player tag. For more information about the usage and considerations for indexes, see Must-read for using indexes.\nThe MATCH statement cannot query dangling edges.\nUsing patterns in MATCH statements\nMatch vertices\nYou can use a user-defined variable in a pair of parentheses to represent a vertex in a pattern. For example: (v).\nnebula> MATCH (v) \\\n        RETURN v \\\n        LIMIT 3;\nMatch tags\nYou can specify a tag with :<tag_name> after the vertex in a pattern.\nnebula> MATCH (v:player) \\\n        RETURN v;\n...\nTo match vertices with multiple tags, use colons (:).\nnebula> CREATE TAG actor (name string, age int);\nnebula> INSERT VERTEX actor(name, age) VALUES \"player100\":(\"Tim Duncan\", 42);\nnebula> MATCH (v:player:actor) \\\n        RETURN v \\\nMatch vertex properties\nYou can specify a vertex property with {<prop_name>: <prop_value>} after the tag in a pattern.\n# The following example uses the name property to match a vertex.\nnebula> MATCH (v:player{name:\"Tim Duncan\"}) \\\n        RETURN v;\nThe WHERE clause can do the same thing:\nnebula> MATCH (v:player) \\\n        WHERE v.player.name == \"Tim Duncan\" \\\n        RETURN v;\nUse the WHERE clause to directly get all the vertices with the vertex property value Tim Duncan.\nnebula> MATCH (v) \\\n        WITH v, properties(v) as props, keys(properties(v)) as kk \\\n        WHERE [i in kk where props[i] == \"Tim Duncan\"] \\\n        RETURN v;\nMatch VIDs\nYou can use the VID to match a vertex. The id() function can retrieve the VID of a vertex.\nnebula> MATCH (v) \\\n        WHERE id(v) == 'player101' \\\n        RETURN v;\nTo match multiple VIDs, use WHERE id(v) IN [vid_list] or WHERE id(v) IN {vid_list}.\nnebula> MATCH (v:player { name: 'Tim Duncan' })--(v2) \\\n        WHERE id(v2) IN [\"player101\", \"player102\"] \\\n        RETURN v2;\nnebula> MATCH (v) WHERE id(v) IN {\"player100\", \"player101\"} \\\n        RETURN v.player.name AS name;\nMatch connected vertices\nYou can use the -- symbol to represent edges of both directions and match vertices connected by these edges.\nnebula> MATCH (v:player{name:\"Tim Duncan\"})--(v2) \\\n        RETURN v2.player.name AS Name;\n...\nYou can add a > or < to the -- symbol to specify the direction of an edge.\nIn the following example, --> represents an edge that starts from v and points to v2. To v, this is an outgoing edge, and to v2 this is an incoming edge.\nnebula> MATCH (v:player{name:\"Tim Duncan\"})-->(v2:player) \\\n        RETURN v2.player.name AS Name;\nTo query the properties of the target vertices, use the CASE expression.\nnebula> MATCH (v:player{name:\"Tim Duncan\"})--(v2) \\\n        RETURN \\\n        CASE WHEN v2.team.name IS NOT NULL \\\n        THEN v2.team.name  \\\n        WHEN v2.player.name IS NOT NULL \\\n        THEN v2.player.name END AS Name;\n...\nTo extend the pattern, you can add more vertices and edges.\nnebula> MATCH (v:player{name:\"Tim Duncan\"})-->(v2)<--(v3) \\\n        RETURN v3.player.name AS Name;\n...\nIf you do not need to refer to a vertex, you can omit the variable representing it in the parentheses.\nnebula> MATCH (v:player{name:\"Tim Duncan\"})-->()<--(v3) \\\n        RETURN v3.player.name AS Name;\n...\nMatch paths\nConnected vertices and edges form a path. You can use a user-defined variable to name a path as follows.\nnebula> MATCH p=(v:player{name:\"Tim Duncan\"})-->(v2) \\\n        RETURN p;\nMatch edges\nnebula> MATCH ()<-[e]-() \\\n        RETURN e \\\n        LIMIT 3;\nMatch edge types\nJust like vertices, you can specify edge types with :<edge_type> in a pattern. For example: -[e:follow]-.\nnebula> MATCH ()-[e:follow]->() \\\n        RETURN e;\n...\nMatch edge type properties\nYou can specify edge type properties with {<prop_name>: <prop_value>} in a pattern. For example: [e:follow{likeness:95}].\nnebula> MATCH (v:player{name:\"Tim Duncan\"})-[e:follow{degree:95}]->(v2) \\\n        RETURN e;\nUse the WHERE clause to directly get all the edges with the edge property value 90.\nnebula> MATCH ()-[e]->() \\\n        WITH e, properties(e) as props, keys(properties(e)) as kk \\\n        WHERE [i in kk where props[i] == 90] \\\n        RETURN e;\n...\nMatch multiple edge types\nThe | symbol can help matching multiple edge types. For example: [e:follow|:serve]. The English colon (:) before the first edge type cannot be omitted, but the English colon before the subsequent edge type can be omitted, such as [e:follow|serve].\nnebula> MATCH (v:player{name:\"Tim Duncan\"})-[e:follow|:serve]->(v2) \\\n        RETURN e;\nMatch multiple edges\nYou can extend a pattern to match multiple edges in a path.\nnebula> MATCH (v:player{name:\"Tim Duncan\"})-[]->(v2)<-[e:serve]-(v3) \\\n        RETURN v2, v3;\n...\nMatch fixed-length paths\nYou can use the :<edge_type>*<hop> pattern to match a fixed-length path. hop must be a non-negative integer.\nnebula> MATCH p=(v:player{name:\"Tim Duncan\"})-[e:follow*2]->(v2) \\\n        RETURN DISTINCT v2 AS Friends;\nIf hop is 0, the pattern will match the source vertex of the path.\nnebula> MATCH (v:player{name:\"Tim Duncan\"}) -[*0]-> (v2) \\\n        RETURN v2;\nMatch variable-length paths\nYou can use the :<edge_type>*[minHop..maxHop] pattern to match variable-length paths.minHop and maxHop are optional and default to 1\nand infinity respectively.\nnebula> MATCH p=(v:player{name:\"Tim Duncan\"})-[e:follow*]->(v2) \\\n        RETURN v2 AS Friends;\n...\nnebula> MATCH p=(v:player{name:\"Tim Duncan\"})-[e:follow*1..3]->(v2) \\\n        RETURN v2 AS Friends;\n...\nnebula> MATCH p=(v:player{name:\"Tim Duncan\"})-[e:follow*1..]->(v2) \\\n        RETURN v2 AS Friends;\n...\nYou can use the DISTINCT keyword to aggregate duplicate results.\nnebula> MATCH p=(v:player{name:\"Tim Duncan\"})-[e:follow*1..3]->(v2:player) \\\n        RETURN DISTINCT v2 AS Friends, count(v2);\nIf minHop is 0, the pattern will match the source vertex of the path. Compared to the preceding statement, the following example uses 0 as the minHop. So in the following result set, \"Tim Duncan\" is counted one more time than it is in the preceding result set because it is the source vertex.\nnebula> MATCH p=(v:player{name:\"Tim Duncan\"})-[e:follow*0..3]->(v2:player) \\\n        RETURN DISTINCT v2 AS Friends, count(v2);\nMatch variable-length paths with multiple edge types\nYou can specify multiple edge types in a fixed-length or variable-length pattern. In this case, hop, minHop, and maxHop take effect on all edge types.\nnebula> MATCH p=(v:player{name:\"Tim Duncan\"})-[e:follow|serve*2]->(v2) \\\n        RETURN DISTINCT v2;\nMatch multiple patterns\nYou can separate multiple patterns with commas (,).\nnebula> CREATE TAG INDEX IF NOT EXISTS team_index ON team(name(20));\nnebula> REBUILD TAG INDEX team_index;\nnebula> MATCH (v1:player{name:\"Tim Duncan\"}), (v2:team{name:\"Spurs\"}) \\\n        RETURN v1,v2;\nMatch shortest paths\nThe allShortestPaths function can be used to find all shortest paths between two vertices.\nnebula> MATCH p = allShortestPaths((a:player{name:\"Tim Duncan\"})-[e*..5]-(b:player{name:\"Tony Parker\"})) \\\n        RETURN p;\nThe shortestPath function can be used to find a single shortest path between two vertices.\nnebula> MATCH p = shortestPath((a:player{name:\"Tim Duncan\"})-[e*..5]-(b:player{name:\"Tony Parker\"})) \\\n        RETURN p;\nRetrieve with multiple match\nMultiple MATCH can be used when different patterns have different filtering criteria and return the rows that exactly match the pattern.\nnebula> MATCH (m)-[]->(n) WHERE id(m)==\"player100\" \\\n        MATCH (n)-[]->(l) WHERE id(n)==\"player125\" \\\n        RETURN id(m),id(n),id(l);\nRetrieve with optional match\nSee OPTIONAL MATCH.",
    "url": "7.general-query-statements/2.match/",
    "type": "doc"
  },
  {
    "title": "OPTIONAL MATCH",
    "content": "The OPTIONAL MATCH clause is used to search for the pattern described in it. OPTIONAL MATCH matches patterns against your graph database, just like MATCH does. The difference is that if no matches are found, OPTIONAL MATCH will use a null for missing parts of the pattern.\nOpenCypher Compatibility\nThis topic applies to the openCypher syntax in nGQL only.\nLimitations\nThe WHERE clause cannot be used in an OPTIONAL MATCH clause.\nExample\nThe example of the use of OPTIONAL MATCH in the MATCH statement is as follows:\nnebula> MATCH (m)-[]->(n) WHERE id(m)==\"player100\" \\\n        OPTIONAL MATCH (n)-[]->(l) \\\n        RETURN id(m),id(n),id(l);\nUsing multiple MATCH instead of OPTIONAL MATCH returns rows that match the pattern exactly. The example is as follows:\nnebula> MATCH (m)-[]->(n) WHERE id(m)==\"player100\" \\\n        MATCH (n)-[]->(l) \\\n        RETURN id(m),id(n),id(l);",
    "url": "7.general-query-statements/optional-match/",
    "type": "doc"
  },
  {
    "title": "LOOKUP",
    "content": "The LOOKUP statement traverses data based on indexes. You can use LOOKUP for the following purposes:\nSearch for the specific data based on conditions defined by the WHERE clause.\nList vertices with a tag: retrieve the VID of all vertices with a tag.\nList edges with an edge type: retrieve the source vertex IDs, destination vertex IDs, and ranks of all edges with an edge type.\nCount the number of vertices or edges with a tag or an edge type.\nOpenCypher compatibility\nThis topic applies to native nGQL only.\nPrecautions\nCorrect use of indexes can speed up queries, but indexes can dramatically reduce the write performance. The performance can be greatly reduced. DO NOT use indexes in production environments unless you are fully aware of their influences on your service.\nIf the specified property is not indexed when using the LOOKUP statement, NebulaGraph randomly selects one of the available indexes.\nFor example, the tag player has two properties, name and age. Both the tag player itself and the property name have indexes, but the property age has no indexes. When running LOOKUP ON player WHERE player.age == 36 YIELD player.name;, NebulaGraph randomly uses one of the indexes of the tag player and the property name. You can use the EXPLAIN statement to check the selected index.\nPrerequisites\nBefore using the LOOKUP statement, make sure that at least one index is created. If there are already related vertices, edges, or properties before an index is created, the user must rebuild the index after creating the index to make it valid.\nSyntax\nLOOKUP ON {<vertex_tag> | <edge_type>}\n[WHERE <expression> [AND <expression> ...]]\nYIELD [DISTINCT] <return_list> [AS <alias>];\n<return_list>\n    <prop_name> [AS <col_alias>] [, <prop_name> [AS <prop_alias>] ...];\nWHERE <expression>: filters data with specified conditions. Both AND and OR are supported between different expressions. For more information, see WHERE.\nYIELD: Define the output to be returned. For details, see YIELD.\nDISTINCT: Aggregate the output results and return the de-duplicated result set.\nAS: Set an alias.\nLimitations of using WHERE in LOOKUP\nThe WHERE clause in a LOOKUP statement does not support the following operations:\n$- and $^.\nFilter rank().\nIn relational expressions, operators are not supported to have field names on both sides, such as tagName.prop1> tagName.prop2.\nNested AliasProp expressions in operation expressions and function expressions are not supported.\nThe XOR operation is not supported.\nString operations other than STARTS WITH are not supported.\nGraph patterns.\nRetrieve vertices\nThe following example returns vertices whose name is Tony Parker and the tag is player.\nnebula> CREATE TAG INDEX IF NOT EXISTS index_player ON player(name(30), age);\nnebula> REBUILD TAG INDEX index_player;\nnebula> LOOKUP ON player \\\n        WHERE player.name == \"Tony Parker\" \\\n        YIELD id(vertex);\nnebula> LOOKUP ON player \\\n        WHERE player.name == \"Tony Parker\" \\\n        YIELD properties(vertex).name AS name, properties(vertex).age AS age;\nnebula> LOOKUP ON player \\\n        WHERE player.age  > 45 \\\n        YIELD id(vertex);\nnebula> LOOKUP ON player \\\n        WHERE player.name STARTS WITH \"B\" \\\n        AND player.age IN [22,30] \\\n        YIELD properties(vertex).name, properties(vertex).age;\nnebula> LOOKUP ON player \\\n        WHERE player.name == \"Kobe Bryant\"\\\n        YIELD id(vertex) AS VertexID, properties(vertex).name AS name |\\\n        GO FROM $-.VertexID OVER serve \\\n        YIELD $-.name, properties(edge).start_year, properties(edge).end_year, properties($$).name;\nRetrieve edges\nThe following example returns edges whose degree is 90 and the edge type is follow.\nnebula> CREATE EDGE INDEX IF NOT EXISTS index_follow ON follow(degree);\nnebula> REBUILD EDGE INDEX index_follow;\nnebula> LOOKUP ON follow \\\n        WHERE follow.degree == 90 YIELD edge AS e;\n...\nnebula> LOOKUP ON follow \\\n        WHERE follow.degree == 90 \\\n        YIELD properties(edge).degree;\n...\nnebula> LOOKUP ON follow \\\n        WHERE follow.degree == 60 \\\n        YIELD dst(edge) AS DstVID, properties(edge).degree AS Degree |\\\n        GO FROM $-.DstVID OVER serve \\\n        YIELD $-.DstVID, properties(edge).start_year, properties(edge).end_year, properties($$).name;\nList vertices or edges with a tag or an edge type\nTo list vertices or edges with a tag or an edge type, at least one index must exist on the tag, the edge type, or its property.\nFor example, if there is a player tag with a name property and an age property, to retrieve the VID of all vertices tagged with player, there has to be an index on the player tag itself, the name property, or the age property.\nThe following example shows how to retrieve the VID of all vertices tagged with player.nebula> CREATE TAG IF NOT EXISTS player(name string,age int);\nnebula> CREATE TAG INDEX IF NOT EXISTS player_index on player();\nnebula> REBUILD TAG INDEX player_index;\nnebula> INSERT VERTEX player(name,age) \\\n        VALUES \"player100\":(\"Tim Duncan\", 42), \"player101\":(\"Tony Parker\", 36);\nThe following statement retrieves the VID of all vertices with the tag `player`. It is similar to `MATCH (n:player) RETURN id(n) /*, n */`.\nnebula> LOOKUP ON player YIELD id(vertex);\n...\nThe following example shows how to retrieve the source Vertex IDs, destination vertex IDs, and ranks of all edges of the follow edge type.nebula> CREATE EDGE IF NOT EXISTS follow(degree int);\nnebula> CREATE EDGE INDEX IF NOT EXISTS follow_index on follow();\nnebula> REBUILD EDGE INDEX follow_index;\nnebula> INSERT EDGE follow(degree) \\\n        VALUES \"player100\"->\"player101\":(95);\nThe following statement retrieves all edges with the edge type `follow`. It is similar to `MATCH (s)-[e:follow]->(d) RETURN id(s), rank(e), id(d) /*, type(e) */`.\nnebula)> LOOKUP ON follow YIELD edge AS e;\n...\nCount the numbers of vertices or edges\nThe following example shows how to count the number of vertices tagged with player and edges of the follow edge type.\nnebula> LOOKUP ON player YIELD id(vertex)|\\\n        YIELD COUNT(*) AS Player_Number;\nnebula> LOOKUP ON follow YIELD edge AS e| \\\n        YIELD COUNT(*) AS Follow_Number;",
    "url": "7.general-query-statements/5.lookup/",
    "type": "doc"
  },
  {
    "title": "GO",
    "content": "GO traverses in a graph with specified filters and returns results.\nOpenCypher compatibility\nThis topic applies to native nGQL only.\nSyntax\nGO [[<M> TO] <N> {STEP|STEPS}] FROM <vertex_list>\nOVER <edge_type_list> [{REVERSELY | BIDIRECT}]\n[ WHERE <conditions> ]\nYIELD [DISTINCT] <return_list>\n[{SAMPLE <sample_list> | <limit_by_list_clause>}]\n[| GROUP BY {col_name | expr | position} YIELD <col_name>]\n[| ORDER BY <expression> [{ASC | DESC}]]\n[| LIMIT [<offset>,] <number_rows>];\n<vertex_list> ::=\n    <vid> [, <vid> ...]\n<edge_type_list> ::=\n   edge_type [, edge_type ...]\n   | *\n<return_list> ::=\n    <col_name> [AS <col_alias>] [, <col_name> [AS <col_alias>] ...]\n<N> {STEP|STEPS}: specifies the hop number. If not specified, the default value for N is one. When N is zero, NebulaGraph does not traverse any edges and returns nothing.\nM TO N {STEP|STEPS}: traverses from M to N hops. When M is zero, the output is the same as that of M is one. That is, the output of GO 0 TO 2 and GO 1 TO 2 are the same.\n<vertex_list>: represents a list of vertex IDs separated by commas, or a special place holder $-.id. For more information, see Pipe.\n<edge_type_list>: represents a list of edge types which the traversal can go through.\nREVERSELY | BIDIRECT: defines the direction of the query. By default, the GO statement searches for outgoing edges of <vertex_list>. If REVERSELY is set, GO searches for incoming edges. If BIDIRECT is set, GO searches for edges of both directions.\nWHERE <expression>: specifies the traversal filters. You can use the WHERE clause for the source vertices, the edges, and the destination vertices. You can use it together with AND, OR, NOT, and XOR. For more information, see WHERE.\nYIELD [DISTINCT] <return_list>: defines the output to be returned. It is recommended to use the Schema-related functions to fill in <return_list>. src(edge), dst(edge), type(edge) ), rank(edge), etc., are currently supported, while nested functions are not. For more information, see YIELD.\nSAMPLE <sample_list>: takes samples from the result set. For more information, see SAMPLE.\n<limit_by_list_clause>: limits the number of outputs during the traversal process. For more information, see LIMIT.\nGROUP BY: groups the output into subgroups based on the value of the specified property. For more information, see GROUP BY. After grouping, you need to use YIELD again to define the output that needs to be returned.\nORDER BY: sorts outputs with specified orders. For more information, see ORDER BY.\nLIMIT  [<offset>,] <number_rows>]: limits the number of rows of the output. For more information, see LIMIT.\nExamples\n# The following example returns the teams that player 102 serves.\nnebula> GO FROM \"player102\" OVER serve YIELD dst(edge);\n# The following example returns the friends of player 102 with 2 hops.\nnebula> GO 2 STEPS FROM \"player102\" OVER follow YIELD dst(edge);\n# The following example adds a filter for the traversal.\nnebula> GO FROM \"player100\", \"player102\" OVER serve \\\n        WHERE properties(edge).start_year > 1995 \\\n        YIELD DISTINCT properties($$).name AS team_name, properties(edge).start_year AS start_year, properties($^).name AS player_name;\n# The following example traverses along with multiple edge types. If there is no value for a property, the output is `NULL`.\nnebula> GO FROM \"player100\" OVER follow, serve \\\n        YIELD properties(edge).degree, properties(edge).start_year;\n# The following example returns the neighbor vertices in the incoming direction of player 100.\nnebula> GO FROM \"player100\" OVER follow REVERSELY \\\n        YIELD src(edge) AS destination;\n...\n# This MATCH query shares the same semantics with the preceding GO query.\nnebula> MATCH (v)<-[e:follow]- (v2) WHERE id(v) == 'player100' \\\n        RETURN id(v2) AS destination;\n...\n# The following example retrieves the friends of player 100 and the teams that they serve.\nnebula> GO FROM \"player100\" OVER follow REVERSELY \\\n        YIELD src(edge) AS id | \\\n        GO FROM $-.id OVER serve \\\n        WHERE properties($^).age > 20 \\\n        YIELD properties($^).name AS FriendOf, properties($$).name AS Team;\n...\n# This MATCH query shares the same semantics with the preceding GO query.\nnebula> MATCH (v)<-[e:follow]- (v2)-[e2:serve]->(v3)  \\\n        WHERE id(v) == 'player100' \\\n        RETURN v2.player.name AS FriendOf, v3.team.name AS Team;\n...\n# The following example retrieves the friends of player 100 within 1 or 2 hops.\nnebula> GO 1 TO 2 STEPS FROM \"player100\" OVER follow \\\n        YIELD dst(edge) AS destination;\n...\n# This MATCH query shares the same semantics with the preceding GO query.\nnebula> MATCH (v) -[e:follow*1..2]->(v2) \\\n        WHERE id(v) == \"player100\" \\\n        RETURN id(v2) AS destination;\n...\n# The following example the outputs according to age.\nnebula> GO 2 STEPS FROM \"player100\" OVER follow \\\n        YIELD src(edge) AS src, dst(edge) AS dst, properties($$).age AS age \\\n        | GROUP BY $-.dst \\\n        YIELD $-.dst AS dst, collect_set($-.src) AS src, collect($-.age) AS age;\n# The following example groups the outputs and restricts the number of rows of the outputs.\nnebula> $a = GO FROM \"player100\" OVER follow YIELD src(edge) AS src, dst(edge) AS dst; \\\n        GO 2 STEPS FROM $a.dst OVER follow \\\n        YIELD $a.src AS src, $a.dst, src(edge), dst(edge) \\\n        | ORDER BY $-.src | OFFSET 1 LIMIT 2;\n# The following example determines if $$.player.name IS NOT EMPTY.\nnebula> GO FROM \"player100\" OVER follow WHERE properties($$).name IS NOT EMPTY YIELD dst(edge);",
    "url": "7.general-query-statements/3.go/",
    "type": "doc"
  },
  {
    "title": "FETCH",
    "content": "The FETCH statement retrieves the properties of the specified vertices or edges.\nOpenCypher Compatibility\nThis topic applies to native nGQL only.\nFetch vertex properties\nSyntax\nFETCH PROP ON {<tag_name>[, tag_name ...] | *}\n<vid> [, vid ...]\nYIELD [DISTINCT] <return_list> [AS <alias>];\nParameter\nDescription\ntag_name\nThe name of the tag.\nRepresents all the tags in the current graph space.\nvid\nThe vertex ID.\nYIELD\nDefine the output to be returned. For details, see YIELD.\nAS\nSet an alias.\nFetch vertex properties by one tag\nSpecify a tag in the FETCH statement to fetch the vertex properties by that tag.\nnebula> FETCH PROP ON player \"player100\" YIELD properties(vertex);\nFetch specific properties of a vertex\nUse a YIELD clause to specify the properties to be returned.\nnebula> FETCH PROP ON player \"player100\" \\\n        YIELD properties(vertex).name AS name;\nFetch properties of multiple vertices\nSpecify multiple VIDs (vertex IDs) to fetch properties of multiple vertices. Separate the VIDs with commas.\nnebula> FETCH PROP ON player \"player101\", \"player102\", \"player103\" YIELD properties(vertex);\nFetch vertex properties by multiple tags\nSpecify multiple tags in the FETCH statement to fetch the vertex properties by the tags. Separate the tags with commas.\n# The following example creates a new tag t1.\nnebula> CREATE TAG IF NOT EXISTS t1(a string, b int);\n# The following example attaches t1 to the vertex \"player100\".\nnebula> INSERT VERTEX t1(a, b) VALUES \"player100\":(\"Hello\", 100);\n# The following example fetches the properties of vertex \"player100\" by the tags player and t1.\nnebula> FETCH PROP ON player, t1 \"player100\" YIELD vertex AS v;\nYou can combine multiple tags with multiple VIDs in a FETCH statement.\nnebula> FETCH PROP ON player, t1 \"player100\", \"player103\" YIELD vertex AS v;\nFetch vertex properties by all tags\nSet an asterisk symbol * to fetch properties by all tags in the current graph space.\nnebula> FETCH PROP ON * \"player100\", \"player106\", \"team200\" YIELD vertex AS v;\nFetch edge properties\nSyntax\nFETCH PROP ON <edge_type> <src_vid> -> <dst_vid>[@<rank>] [, <src_vid> -> <dst_vid> ...]\nYIELD <output>;\nParameter\nDescription\nedge_type\nThe name of the edge type.\nsrc_vid\nThe VID of the source vertex. It specifies the start of an edge.\ndst_vid\nThe VID of the destination vertex. It specifies the end of an edge.\nrank\nThe rank of the edge. It is optional and defaults to 0. It distinguishes an edge from other edges with the same edge type, source vertex, destination vertex, and rank.\nYIELD\nDefine the output to be returned. For details, see YIELD.\nFetch all properties of an edge\nThe following statement fetches all the properties of the serve edge that connects vertex \"player100\" and vertex \"team204\".\nnebula> FETCH PROP ON serve \"player100\" -> \"team204\" YIELD properties(edge);\nFetch specific properties of an edge\nUse a YIELD clause to fetch specific properties of an edge.\nnebula> FETCH PROP ON serve \"player100\" -> \"team204\"    \\\n        YIELD properties(edge).start_year;\nFetch properties of multiple edges\nSpecify multiple edge patterns (<src_vid> -> <dst_vid>[@<rank>]) to fetch properties of multiple edges. Separate the edge patterns with commas.\nnebula> FETCH PROP ON serve \"player100\" -> \"team204\", \"player133\" -> \"team202\" YIELD edge AS e;\nFetch properties based on edge rank\nIf there are multiple edges with the same edge type, source vertex, and destination vertex, you can specify the rank to fetch the properties on the correct edge.\n# The following example inserts edges with different ranks and property values.\nnebula> insert edge serve(start_year,end_year) \\\n        values \"player100\"->\"team204\"@1:(1998, 2017);\nnebula> insert edge serve(start_year,end_year) \\\n        values \"player100\"->\"team204\"@2:(1990, 2018);\n# By default, the FETCH statement returns the edge whose rank is 0.\nnebula> FETCH PROP ON serve \"player100\" -> \"team204\" YIELD edge AS e;\n# To fetch on an edge whose rank is not 0, set its rank in the FETCH statement.\nnebula> FETCH PROP ON serve \"player100\" -> \"team204\"@1 YIELD edge AS e;\nUse FETCH in composite queries\nA common way to use FETCH is to combine it with native nGQL such as GO.\nThe following statement returns the degree values of the follow edges that start from vertex \"player101\".\nnebula> GO FROM \"player101\" OVER follow \\\n        YIELD src(edge) AS s, dst(edge) AS d \\\n        | FETCH PROP ON follow $-.s -> $-.d \\\n        YIELD properties(edge).degree;\nOr you can use user-defined variables to construct similar queries.\nnebula> $var = GO FROM \"player101\" OVER follow \\\n        YIELD src(edge) AS s, dst(edge) AS d; \\\n        FETCH PROP ON follow $var.s -> $var.d \\\n        YIELD properties(edge).degree;\nFor more information about composite queries, see Composite queries (clause structure).",
    "url": "7.general-query-statements/4.fetch/",
    "type": "doc"
  },
  {
    "title": "SHOW CHARSET",
    "content": "The SHOW CHARSET statement shows the available character sets.\nCurrently available types are utf8 and utf8mb4. The default charset type is utf8. NebulaGraph extends the uft8 to support four-byte characters. Therefore utf8 and utf8mb4 are equivalent.\nSyntax\nSHOW CHARSET;\nExample\nnebula> SHOW CHARSET;\nParameter\nDescription\nCharset\nThe name of the character set.\nDescription\nThe description of the character set.\nDefault collation\nThe default collation of the character set.\nMaxlen\nThe maximum number of bytes required to store one character.",
    "url": "7.general-query-statements/6.show/1.show-charset/",
    "type": "doc"
  },
  {
    "title": "SHOW COLLATION",
    "content": "The SHOW COLLATION statement shows the collations supported by NebulaGraph.\nCurrently available types are: utf8_bin and utf8mb4_bin.\nWhen the character set is utf8, the default collate is utf8_bin.\nWhen the character set is utf8mb4, the default collate is utf8mb4_bin.\nSyntax\nSHOW COLLATION;\nExample\nnebula> SHOW COLLATION;\nParameter\nDescription\nCollation\nThe name of the collation.\nCharset\nThe name of the character set with which the collation is associated.",
    "url": "7.general-query-statements/6.show/2.show-collation/",
    "type": "doc"
  },
  {
    "title": "SHOW CREATE SPACE",
    "content": "The SHOW CREATE SPACE statement shows the creating statement of the specified graph space.\nFor details about the graph space information, see CREATE SPACE.\nSyntax\nSHOW CREATE SPACE <space_name>;\nExample\nnebula> SHOW CREATE SPACE basketballplayer;",
    "url": "7.general-query-statements/6.show/4.show-create-space/",
    "type": "doc"
  },
  {
    "title": "SHOW CREATE TAG/EDGE",
    "content": "The SHOW CREATE TAG statement shows the basic information of the specified tag. For details about the tag, see CREATE TAG.\nThe SHOW CREATE EDGE statement shows the basic information of the specified edge type. For details about the edge type, see CREATE EDGE.\nSyntax\nSHOW CREATE {TAG <tag_name> | EDGE <edge_name>};\nExamples\nnebula> SHOW CREATE TAG player;\nnebula> SHOW CREATE EDGE follow;",
    "url": "7.general-query-statements/6.show/5.show-create-tag-edge/",
    "type": "doc"
  },
  {
    "title": "SHOW HOSTS",
    "content": "The SHOW HOSTS statement shows the cluster information, including the port, status, leader, partition, and version information. You can also add the service type in the statement to view the information of the specific service.\nSyntax\nSHOW HOSTS [GRAPH | STORAGE | META];\nExamples\nnebula> SHOW HOSTS;\nnebula> SHOW HOSTS GRAPH;\nnebula> SHOW HOSTS STORAGE;\nnebula> SHOW HOSTS META;",
    "url": "7.general-query-statements/6.show/6.show-hosts/",
    "type": "doc"
  },
  {
    "title": "SHOW INDEX STATUS",
    "content": "The SHOW INDEX STATUS statement shows the status of jobs that rebuild native indexes, which helps check whether a native index is successfully rebuilt or not.\nSyntax\nSHOW {TAG | EDGE} INDEX STATUS;\nExamples\nnebula> SHOW TAG INDEX STATUS;\nnebula> SHOW EDGE INDEX STATUS;\nRelated topics\nJob manager and the JOB statements\nREBUILD NATIVE INDEX",
    "url": "7.general-query-statements/6.show/7.show-index-status/",
    "type": "doc"
  },
  {
    "title": "SHOW INDEXES",
    "content": "The SHOW INDEXES statement shows the names of existing native indexes.\nSyntax\nSHOW {TAG | EDGE} INDEXES;\nExamples\nnebula> SHOW TAG INDEXES;\nnebula> SHOW EDGE INDEXES;",
    "url": "7.general-query-statements/6.show/8.show-indexes/",
    "type": "doc"
  },
  {
    "title": "SHOW PARTS",
    "content": "The SHOW PARTS statement shows the information of a specified partition or all partitions in a graph space.\nSyntax\nSHOW PARTS [<part_id>];\nExamples\nnebula> SHOW PARTS;\nnebula> SHOW PARTS 1;\nThe descriptions are as follows.\nParameter\nDescription\nPartition ID\nThe ID of the partition.\nLeader\nThe IP address and the port of the leader.\nPeers\nThe IP addresses and the ports of all the replicas.\nLosts\nThe IP addresses and the ports of replicas at fault.",
    "url": "7.general-query-statements/6.show/9.show-parts/",
    "type": "doc"
  },
  {
    "title": "SHOW ROLES",
    "content": "The SHOW ROLES statement shows the roles that are assigned to a user account.\nThe return message differs according to the role of the user who is running this statement:\nIf the user is a GOD or ADMIN and is granted access to the specified graph space, NebulaGraph shows all roles in this graph space except for GOD.\nIf the user is a DBA, USER, or GUEST and is granted access to the specified graph space, NebulaGraph shows the user's own role in this graph space.\nIf the user does not have access to the specified graph space, NebulaGraph returns PermissionError.\nFor more information about roles, see Roles and privileges.\nSyntax\nSHOW ROLES IN <space_name>;\nExample\nnebula> SHOW ROLES in basketballplayer;",
    "url": "7.general-query-statements/6.show/10.show-roles/",
    "type": "doc"
  },
  {
    "title": "SHOW SNAPSHOTS",
    "content": "The SHOW SNAPSHOTS statement shows the information of all the snapshots.\nFor how to create a snapshot and backup data, see Snapshot.\nRole requirement\nOnly the root user who has the GOD role can use the SHOW SNAPSHOTS statement.\nSyntax\nSHOW SNAPSHOTS;\nExample\nnebula> SHOW SNAPSHOTS;",
    "url": "7.general-query-statements/6.show/11.show-snapshots/",
    "type": "doc"
  },
  {
    "title": "SHOW SPACES",
    "content": "The SHOW SPACES statement shows existing graph spaces in NebulaGraph.\nFor how to create a graph space, see CREATE SPACE.\nSyntax\nSHOW SPACES;\nExample\nnebula> SHOW SPACES;",
    "url": "7.general-query-statements/6.show/12.show-spaces/",
    "type": "doc"
  },
  {
    "title": "SHOW STATS",
    "content": "The SHOW STATS statement shows the statistics of the graph space collected by the latest SUBMIT JOB STATS job.\nThe statistics include the following information:\nThe number of vertices in the graph space\nThe number of edges in the graph space\nThe number of vertices of each tag\nThe number of edges of each edge type\nPrerequisites\nYou have to run the SUBMIT JOB STATS statement in the graph space where you want to collect statistics. For more information, see SUBMIT JOB STATS.\nSyntax\nSHOW STATS;\nExamples\n# Choose a graph space.\nnebula> USE basketballplayer;\n# Start SUBMIT JOB STATS.\nnebula> SUBMIT JOB STATS;\n# Make sure the job executes successfully.\nnebula> SHOW JOB 98;\n# Show the statistics of the graph space.\nnebula> SHOW STATS;",
    "url": "7.general-query-statements/6.show/14.show-stats/",
    "type": "doc"
  },
  {
    "title": "SHOW TAGS/EDGES",
    "content": "The SHOW TAGS statement shows all the tags in the current graph space.\nThe SHOW EDGES statement shows all the edge types in the current graph space.\nSyntax\nSHOW {TAGS | EDGES};\nExamples\nnebula> SHOW TAGS;\nnebula> SHOW EDGES;",
    "url": "7.general-query-statements/6.show/15.show-tags-edges/",
    "type": "doc"
  },
  {
    "title": "SHOW USERS",
    "content": "The SHOW USERS statement shows the user information.\nRole requirement\nOnly the root user who has the GOD role can use the SHOW USERS statement.\nSyntax\nSHOW USERS;\nExample\nnebula> SHOW USERS;",
    "url": "7.general-query-statements/6.show/16.show-users/",
    "type": "doc"
  },
  {
    "title": "SHOW SESSIONS",
    "content": "When a user logs in to the database, a corresponding session will be created and users can query for session information.\nThe SHOW SESSIONS statement shows the information of all the sessions. It can also show a specified session with its ID.\nPrecautions\nThe client will call the API release to release the session and clear the session information when you run exit after the operation ends. If you exit the database in an unexpected way and the session timeout duration is not set via session_idle_timeout_secs in nebula-graphd.conf, the session will not be released automatically. For those sessions that are not automatically released, you need to delete them manually. For details, see KILL SESSIONS.\nSHOW SESSIONS queries the session information of all the Graph services.\nSHOW LOCAL SESSIONS queries the session information of the currently connected Graph service and does not query the session information of other Graph services.\nSHOW SESSION <Session_Id> queries the session information with a specific session id.\nSyntax\nSHOW [LOCAL] SESSIONS;\nSHOW SESSION <Session_Id>;\nExamples\nnebula> SHOW SESSIONS;\nnebula> SHOW SESSION 1635254859271703;\nParameter\nDescription\nSessionId\nThe session ID, namely the identifier of a session.\nUserName\nThe username in a session.\nSpaceName\nThe name of the graph space that the user uses currently. It is null (\"\") when you first log in because there is no specified graph space.\nCreateTime\nThe time when the session is created, namely the time when the user logs in. The time zone is specified by timezone_name in the configuration file.\nUpdateTime\nThe system will update the time when there is an operation. The time zone is specified by timezone_name in the configuration file.\nGraphAddr\nThe IP address and port of the Graph server that hosts the session.\nTimezone\nA reserved parameter that has no specified meaning for now.\nClientIp\nThe IP address of the client.",
    "url": "7.general-query-statements/6.show/17.show-sessions/",
    "type": "doc"
  },
  {
    "title": "SHOW QUERIES",
    "content": "The SHOW QUERIES statement shows the information of working queries in the current session.\nPrecautions\nThe SHOW LOCAL QUERIES statement gets the status of queries in the current session from the local cache with almost no latency.\nThe SHOW QUERIES statement gets the information of queries in all the sessions from the Meta Service. The information will be synchronized to the Meta Service according to the interval defined by session_reclaim_interval_secs. Therefore the information that you get from the client may belong to the last synchronization interval.\nSyntax\nSHOW [LOCAL] QUERIES;\nExamples\nnebula> SHOW LOCAL QUERIES;\nnebula> SHOW QUERIES;\n# The following statement returns the top 10 queries that have the longest duration.\nnebula> SHOW QUERIES | ORDER BY $-.DurationInUSec DESC | LIMIT 10;\nThe descriptions are as follows.\nParameter\nDescription\nSessionID\nThe session ID.\nExecutionPlanID\nThe ID of the execution plan.\nUser\nThe username that executes the query.\nHost\nThe IP address and port of the Graph server that hosts the session.\nStartTime\nThe time when the query starts.\nDurationInUSec\nThe duration of the query. The unit is microsecond.\nStatus\nThe current status of the query.\nQuery\nThe query statement.",
    "url": "7.general-query-statements/6.show/18.show-queries/",
    "type": "doc"
  },
  {
    "title": "SHOW META LEADER",
    "content": "The SHOW META LEADER statement shows the information of the leader in the current Meta cluster.\nFor more information about the Meta service, see Meta service.\nSyntax\nSHOW META LEADER;\nExample\nnebula> SHOW META LEADER;\nParameter\nDescription\nMeta Leader\nShows the information of the leader in the Meta cluster, including the IP address and port of the server where the leader is located.\nsecs from last heart beat\nIndicates the time interval since the last heartbeat. This parameter is measured in seconds.",
    "url": "7.general-query-statements/6.show/19.show-meta-leader/",
    "type": "doc"
  },
  {
    "title": "GROUP BY",
    "content": "The GROUP BY clause can be used to aggregate data.\nOpenCypher Compatibility\nThis topic applies to native nGQL only.\nYou can also use the count() function to aggregate data.\nnebula>  MATCH (v:player)<-[:follow]-(:player) RETURN v.player.name AS Name, count(*) as cnt ORDER BY cnt DESC;\n...\nSyntax\nThe GROUP BY clause groups the rows with the same value. Then operations such as counting, sorting, and calculation can be applied.\nThe GROUP BY clause works after the pipe symbol (|) and before a YIELD clause.\n| GROUP BY <var> YIELD <var>, <aggregation_function(var)>\nThe aggregation_function() function supports avg(), sum(), max(), min(), count(), collect(), and std().\nExamples\nThe following statement finds all the vertices connected directly to vertex \"player100\", groups the result set by player names, and counts how many times the name shows up in the result set.\nnebula> GO FROM \"player100\" OVER follow BIDIRECT \\\n        YIELD properties($$).name as Name \\\n        | GROUP BY $-.Name \\\n        YIELD $-.Name as Player, count(*) AS Name_Count;\nThe following statement finds all the vertices connected directly to vertex \"player100\", groups the result set by source vertices, and returns the sum of degree values.\nnebula> GO FROM \"player100\" OVER follow \\\n        YIELD src(edge) AS player, properties(edge).degree AS degree \\\n        | GROUP BY $-.player \\\n        YIELD sum($-.degree);\nFor more information about the sum() function, see Built-in math functions.\nImplicit GROUP BY\nThe usage of GROUP BY in the above nGQL statements that explicitly write GROUP BY and act as grouping fields is called explicit GROUP BY, while in openCypher, the GROUP BY is implicit, i.e., GROUP BY groups fields without explicitly writing GROUP BY. The explicit GROUP BY in nGQL is the same as the implicit GROUP BY in openCypher, and nGQL also supports the implicit GROUP BY. For the implicit usage of GROUP BY, see how-to-make-group-by-in-a-cypher-query.\nFor example, to look up the players over 34 years old with the same length of service, you can use the following statement:\nnebula> LOOKUP ON player WHERE player.age > 34 YIELD id(vertex) AS v | \\\n        GO FROM $-.v OVER serve YIELD serve.start_year AS start_year, serve.end_year AS end_year | \\\n        YIELD $-.start_year, $-.end_year, count(*) AS count | \\\n        ORDER BY $-.count DESC | LIMIT 5;\n+---------------+-------------+-------+ ",
    "url": "8.clauses-and-options/group-by/",
    "type": "doc"
  },
  {
    "title": "LIMIT AND SKIP",
    "content": "The LIMIT clause constrains the number of rows in the output. The usage of LIMIT in native nGQL statements and openCypher compatible statements is different.\nNative nGQL: Generally, a pipe | needs to be used before the LIMIT clause. The offset parameter can be set or omitted directly after the LIMIT statement.\nOpenCypher compatible statements: No pipes are permitted before the LIMIT clause. And you can use SKIP to indicate an offset.\nLIMIT in native nGQL statements\nIn native nGQL, LIMIT has general syntax and exclusive syntax in GO statements.\nGeneral LIMIT syntax in native nGQL statements\nIn native nGQL,  the general LIMIT syntax works the same as in SQL. The LIMIT clause accepts one or two parameters. The values of both parameters must be non-negative integers and be used after a pipe. The syntax and description are as follows:\n... | LIMIT [<offset>,] <number_rows>;\nParameter\nDescription\noffset\nThe offset value. It defines the row from which to start returning. The offset starts from 0. The default value is 0, which returns from the first row.\nnumber_rows\nIt constrains the total number of returned rows.\nFor example:\n# The following example returns the top 3 rows of data from the result.\nnebula> LOOKUP ON player YIELD id(vertex)|\\\n        LIMIT 3;\n# The following example returns the 3 rows of data starting from the second row of the sorted output.\nnebula> GO FROM \"player100\" OVER follow REVERSELY \\\n        YIELD properties($$).name AS Friend, properties($$).age AS Age \\\n        | ORDER BY $-.Age, $-.Friend \\\n        | LIMIT 1, 3;\nLIMIT in GO statements\nIn addition to the general syntax in the native nGQL, the LIMIT in the GO statement also supports limiting the number of output results based on edges.\nSyntax:\n<go_statement> LIMIT <limit_list>;\nlimit_list is a list. Elements in the list must be natural numbers, and the number of elements must be the same as the maximum number of STEPS in the GO statement. The following takes GO 1 TO 3 STEPS FROM \"A\" OVER * LIMIT <limit_list> as an example to introduce this usage of LIMIT in detail.\nThe list limit_list must contain 3 natural numbers, such as GO 1 TO 3 STEPS FROM \"A\" OVER * LIMIT [1,2,4].\n1 in LIMIT [1,2,4] means that the system automatically selects 1 edge to continue traversal in the first step. 2 means to select 2 edges to continue traversal in the second step. 4 indicates that 4 edges are selected to continue traversal in the third step.\nBecause GO 1 TO 3 STEPS means to return all the traversal results from the first to third steps, all the red edges and their source and destination vertices in the figure below will be matched by this GO statement. And the yellow edges represent there is no path selected when the GO statement traverses. If it is not GO 1 TO 3 STEPS but GO 3 STEPS, it will only match the red edges of the third step and the vertices at both ends.\nIn the basketballplayer dataset, the example is as follows:\nnebula> GO 3 STEPS FROM \"player100\" \\\n        OVER * \\\n        YIELD properties($$).name AS NAME, properties($$).age AS Age \\\n        LIMIT [3,3,3];\nnebula> GO 3 STEPS FROM \"player102\" OVER * BIDIRECT\\\n        YIELD dst(edge) \\\n        LIMIT [rand32(5),rand32(5),rand32(5)];\nLIMIT in openCypher compatible statements\nIn openCypher compatible statements such as MATCH, there is no need to use a pipe when LIMIT is used. The syntax and description are as follows:\n... [SKIP <offset>] [LIMIT <number_rows>];\nParameter\nDescription\noffset\nThe offset value. It defines the row from which to start returning. The offset starts from 0. The default value is 0, which returns from the first row.\nnumber_rows\nIt constrains the total number of returned rows.\nBoth offset and number_rows accept expressions, but the result of the expression must be a non-negative integer.\nExamples of LIMIT\nLIMIT can be used alone to return a specified number of results.\nnebula> MATCH (v:player) RETURN v.player.name AS Name, v.player.age AS Age \\\n        ORDER BY Age LIMIT 5;\nExamples of SKIP\nSKIP can be used alone to set the offset and return the data after the specified position.\nnebula> MATCH (v:player{name:\"Tim Duncan\"}) --> (v2) \\\n        RETURN v2.player.name AS Name, v2.player.age AS Age \\\n        ORDER BY Age DESC SKIP 1;\nnebula> MATCH (v:player{name:\"Tim Duncan\"}) --> (v2) \\\n        RETURN v2.player.name AS Name, v2.player.age AS Age \\\n        ORDER BY Age DESC SKIP 1+1;\nExample of SKIP and LIMIT\nSKIP and LIMIT can be used together to return the specified amount of data starting from the specified position.\nnebula> MATCH (v:player{name:\"Tim Duncan\"}) --> (v2) \\\n        RETURN v2.player.name AS Name, v2.player.age AS Age \\\n        ORDER BY Age DESC SKIP 1 LIMIT 1;",
    "url": "8.clauses-and-options/limit/",
    "type": "doc"
  },
  {
    "title": "SAMPLE",
    "content": "The SAMPLE clause takes samples evenly in the result set and returns the specified amount of data.\nSAMPLE can be used in GO statements only. The syntax is as follows:\n<go_statement> SAMPLE <sample_list>;\nsample_list is a list. Elements in the list must be natural numbers, and the number of elements must be the same as the maximum number of STEPS in the GO statement. The following takes GO 1 TO 3 STEPS FROM \"A\" OVER * SAMPLE <sample_list> as an example to introduce this usage of SAMPLE in detail.\nThe list sample_list must contain 3 natural numbers, such as GO 1 TO 3 STEPS FROM \"A\" OVER * SAMPLE [1,2,4].\n1 in SAMPLE [1,2,4] means that the system automatically selects 1 edge to continue traversal in the first step. 2 means to select 2 edges to continue traversal in the second step. 4 indicates that 4 edges are selected to continue traversal in the third step. If there is no matched edge in a certain step or the number of matched edges is less than the specified number, the actual number will be returned.\nBecause GO 1 TO 3 STEPS means to return all the traversal results from the first to third steps, all the red edges and their source and destination vertices in the figure below will be matched by this GO statement. And the yellow edges represent there is no path selected when the GO statement traverses. If it is not GO 1 TO 3 STEPS but GO 3 STEPS, it will only match the red edges of the third step and the vertices at both ends.\nIn the basketballplayer dataset, the example is as follows:\nnebula> GO 3 STEPS FROM \"player100\" \\\n        OVER * \\\n        YIELD properties($$).name AS NAME, properties($$).age AS Age \\\n        SAMPLE [1,2,3];\nnebula> GO 1 TO 3 STEPS FROM \"player100\" \\\n        OVER * \\\n        YIELD properties($$).name AS NAME, properties($$).age AS Age \\\n        SAMPLE [2,2,2];",
    "url": "8.clauses-and-options/sample/",
    "type": "doc"
  },
  {
    "title": "ORDER BY",
    "content": "The ORDER BY clause specifies the order of the rows in the output.\nNative nGQL: You must use a pipe (|) and an ORDER BY clause after YIELD clause.\nOpenCypher style: No pipes are permitted. The ORDER BY clause follows a RETURN clause.\nThere are two order options:\nASC: Ascending. ASC is the default order.\nDESC: Descending.\nNative nGQL Syntax\n<YIELD clause>\n| ORDER BY <expression> [ASC | DESC] [, <expression> [ASC | DESC] ...];\nExamples\nnebula> FETCH PROP ON player \"player100\", \"player101\", \"player102\", \"player103\" \\\n        YIELD player.age AS age, player.name AS name \\\n        | ORDER BY $-.age ASC, $-.name DESC;\nnebula> $var = GO FROM \"player100\" OVER follow \\\n        YIELD dst(edge) AS dst; \\\n        ORDER BY $var.dst DESC;\nOpenCypher Syntax\n<RETURN clause>\nORDER BY <expression> [ASC | DESC] [, <expression> [ASC | DESC] ...];\nExamples\nnebula> MATCH (v:player) RETURN v.player.name AS Name, v.player.age AS Age  \\\n        ORDER BY Name DESC;\n...\n# In the following example, nGQL sorts the rows by age first. If multiple people are of the same age, nGQL will then sort them by name.\nnebula> MATCH (v:player) RETURN v.player.age AS Age, v.player.name AS Name  \\\n        ORDER BY Age DESC, Name ASC;\n...\nOrder of NULL values\nnGQL lists NULL values at the end of the output for ascending sorting, and at the start for descending sorting.\nnebula> MATCH (v:player{name:\"Tim Duncan\"}) --> (v2) \\\n        RETURN v2.player.name AS Name, v2.player.age AS Age  \\\n        ORDER BY Age;\nnebula> MATCH (v:player{name:\"Tim Duncan\"}) --> (v2) \\\n        RETURN v2.player.name AS Name, v2.player.age AS Age  \\\n        ORDER BY Age DESC;",
    "url": "8.clauses-and-options/order-by/",
    "type": "doc"
  },
  {
    "title": "RETURN",
    "content": "The RETURN clause defines the output of an nGQL query. To return multiple fields, separate them with commas.\nRETURN can lead a clause or a statement:\nA RETURN clause can work in openCypher statements in nGQL, such as MATCH or UNWIND.\nA RETURN statement can work independently to output the result of an expression.\nOpenCypher compatibility\nThis topic applies to the openCypher syntax in nGQL only. For native nGQL, use YIELD.\nRETURN does not support the following openCypher features yet.\nReturn variables with uncommon characters, for example:\nMATCH (`non-english_characters`:player) \\\nRETURN `non-english_characters`;\nSet a pattern in the RETURN clause and return all elements that this pattern matches, for example:\nMATCH (v:player) \\\nRETURN (v)-[e]->(v2);\nMap order description\nWhen RETURN returns the map data structure, the order of key-value pairs is undefined.\nnebula> RETURN {age: 32, name: \"Marco Belinelli\"};\nnebula> RETURN {zage: 32, name: \"Marco Belinelli\"};\nReturn vertices or edges\nUse the RETURN {<vertex_name> | <edge_name>} to return vertices and edges all information.\n// Return vertices\nnebula> MATCH (v:player) \\\n        RETURN v;\n...\n// Return edges\nnebula> MATCH (v:player)-[e]->() \\\n        RETURN e;\n...\nReturn VIDs\nUse the id() function to retrieve VIDs.\nnebula> MATCH (v:player{name:\"Tim Duncan\"}) \\\n        RETURN id(v);\nReturn Tag\nUse the labels() function to return the list of tags on a vertex.\nnebula> MATCH (v:player{name:\"Tim Duncan\"}) \\\n        RETURN labels(v);\nTo retrieve the nth element in the labels(v) list, use labels(v)[n-1]. The following example shows how to use labels(v)[0] to return the first tag in the list.\nnebula> MATCH (v:player{name:\"Tim Duncan\"}) \\\n        RETURN labels(v)[0];\nReturn properties\nWhen returning properties of a vertex, it is necessary to specify the tag to which the properties belong because a vertex can have multiple tags and the same property name can appear on different tags.\nIt is possible to specify the tag of a vertex to return all properties of that tag, or to specify both the tag and a property name to return only that property of the tag.\nnebula> MATCH (v:player) \\\n        RETURN v.player, v.player.name, v.player.age \\\n        LIMIT 3;\nWhen returning edge properties, it is not necessary to specify the edge type to which the properties belong, because an edge can only have one edge type.\n// Return the property of a vertex\nnebula> MATCH p=(v:player{name:\"Tim Duncan\"})-[]->(v2) \\\n        RETURN properties(v2);\n// Return the property of an edge\nnebula> MATCH (v:player{name:\"Tim Duncan\"})-[e]->() \\\n        RETURN e.start_year, e.degree \\\nReturn edge type\nUse the type() function to return the matched edge types.\nnebula> MATCH p=(v:player{name:\"Tim Duncan\"})-[e]->() \\\n        RETURN DISTINCT type(e);\nReturn paths\nUse RETURN <path_name> to return all the information of the matched paths.\nnebula> MATCH p=(v:player{name:\"Tim Duncan\"})-[*3]->() \\\n        RETURN p;\n...\nReturn vertices in a path\nUse the nodes() function to return all vertices in a path.\nnebula> MATCH p=(v:player{name:\"Tim Duncan\"})-[]->(v2) \\\n        RETURN nodes(p);\nReturn edges in a path\nUse the relationships() function to return all edges in a path.\nnebula> MATCH p=(v:player{name:\"Tim Duncan\"})-[]->(v2) \\\n        RETURN relationships(p);\nReturn path length\nUse the length() function to return the length of a path.\nnebula> MATCH p=(v:player{name:\"Tim Duncan\"})-[*..2]->(v2) \\\n        RETURN p AS Paths, length(p) AS Length;\nReturn all elements\nTo return all the elements that this pattern matches, use an asterisk (*).\nnebula> MATCH (v:player{name:\"Tim Duncan\"}) \\\n        RETURN *;\nnebula> MATCH (v:player{name:\"Tim Duncan\"})-[e]->(v2) \\\n        RETURN *;\nRename a field\nUse the AS <alias> syntax to rename a field in the output.\nnebula> MATCH (v:player{name:\"Tim Duncan\"})-[:serve]->(v2) \\\n        RETURN v2.team.name AS Team;\nnebula> RETURN \"Amber\" AS Name;\nReturn a non-existing property\nIf a property matched does not exist, NULL is returned.\nnebula> MATCH (v:player{name:\"Tim Duncan\"})-[e]->(v2) \\\n        RETURN v2.player.name, type(e), v2.player.age;\nReturn expression results\nTo return the results of expressions such as literals, functions, or predicates, set them in a RETURN clause.\nnebula> MATCH (v:player{name:\"Tony Parker\"})-->(v2:player) \\\n        RETURN DISTINCT v2.player.name, \"Hello\"+\" graphs!\", v2.player.age > 35;\nnebula> RETURN 1+1;\nnebula> RETURN 1- -1;\nnebula> RETURN 3 > 1;\nnebula> RETURN 1+1, rand32(1, 5);\nReturn unique fields\nUse DISTINCT to remove duplicate fields in the result set.\n# Before using DISTINCT.\nnebula> MATCH (v:player{name:\"Tony Parker\"})--(v2:player) \\\n        RETURN v2.player.name, v2.player.age;\n# After using DISTINCT.\nnebula> MATCH (v:player{name:\"Tony Parker\"})--(v2:player) \\\n        RETURN DISTINCT v2.player.name, v2.player.age;",
    "url": "8.clauses-and-options/return/",
    "type": "doc"
  },
  {
    "title": "TTL",
    "content": "TTL (Time To Live) specifies a timeout for a property. Once timed out, the property expires.\nOpenCypher Compatibility\nThis topic applies to native nGQL only.\nPrecautions\nYou CANNOT modify a property schema with TTL options on it.\nTTL options and indexes have coexistence issues.\nTTL options and indexes CANNOT coexist on a tag or an edge type. If there is an index on a property, you cannot set TTL options on other properties.\nIf there are TTL options on a tag, an edge type, or a property, you can still add an index on them.\nTTL options\nThe native nGQL TTL feature has the following options.\nOption\nDescription\nttl_col\nSpecifies the property to set a timeout on. The data type of the property must be int or timestamp.\nttl_duration\nSpecifies the timeout adds-on value in seconds. The value must be a non-negative int64 number. A property expires if the sum of its value and the ttl_duration value is smaller than the current timestamp. If the ttl_duration value is 0, the property never expires.You can set ttl_use_ms to true in the configuration file nebula-storaged.conf (default path: /usr/local/nightly/etc/) to set the default unit to milliseconds.\nData expiration and deletion\nVertex property expiration\nVertex property expiration has the following impact.\nIf a vertex has only one tag, once a property of the vertex expires, the vertex expires.\nIf a vertex has multiple tags, once a property of the vertex expires, properties bound to the same tag with the expired property also expire, but the vertex does not expire and other properties of it remain untouched.\nEdge property expiration\nSince an edge can have only one edge type, once an edge property expires, the edge expires.\nData deletion\nThe expired data are still stored on the disk, but queries will filter them out.\nNebulaGraph automatically deletes the expired data and reclaims the disk space during the next compaction.\nUse TTL options\nYou must use the TTL options together to set a valid timeout on a property.\nSet a timeout if a tag or an edge type exists\nIf a tag or an edge type is already created, to set a timeout on a property bound to the tag or edge type, use ALTER to update the tag or edge type.\n# Create a tag.\nnebula> CREATE TAG IF NOT EXISTS t1 (a timestamp);\n# Use ALTER to update the tag and set the TTL options.\nnebula> ALTER TAG t1 TTL_COL = \"a\", TTL_DURATION = 5;\n# Insert a vertex with tag t1. The vertex expires 5 seconds after the insertion.\nnebula> INSERT VERTEX t1(a) VALUES \"101\":(now());\nSet a timeout when creating a tag or an edge type\nUse TTL options in the CREATE statement to set a timeout when creating a tag or an edge type. For more information, see CREATE TAG and CREATE EDGE.\n# Create a tag and set the TTL options.\nnebula> CREATE TAG IF NOT EXISTS t2(a int, b int, c string) TTL_DURATION= 100, TTL_COL = \"a\";\n# Insert a vertex with tag t2. The timeout timestamp is 1648197238 (1648197138 + 100).\nnebula> INSERT VERTEX t2(a, b, c) VALUES \"102\":(1648197138, 30, \"Hello\");\nRemove a timeout\nTo disable TTL and remove the timeout on a property, you can use the following approaches.\nDrop the property with the timeout.nebula> ALTER TAG t1 DROP (a);\nSet ttl_col to an empty string.nebula> ALTER TAG t1 TTL_COL = \"\";\nSet ttl_duration to 0. This operation keeps the TTL options and prevents the property from expiring and the property schema from being modified.nebula> ALTER TAG t1 TTL_DURATION = 0;",
    "url": "8.clauses-and-options/ttl-options/",
    "type": "doc"
  },
  {
    "title": "WHERE",
    "content": "The WHERE clause filters the output by conditions.\nThe WHERE clause usually works in the following queries:\nNative nGQL: such as GO and LOOKUP.\nOpenCypher syntax: such as MATCH and WITH.\nOpenCypher compatibility\nFiltering on edge rank is a native nGQL feature. To retrieve the rank value in openCypher statements, use the rank() function, such as MATCH (:player)-[e:follow]->() RETURN rank(e);.\nBasic usage\nDefine conditions with boolean operators\nUse the boolean operators NOT, AND, OR, and XOR to define conditions in WHERE clauses. For the precedence of the operators, see Precedence.\nnebula> MATCH (v:player) \\\n        WHERE v.player.name == \"Tim Duncan\" \\\n        XOR (v.player.age < 30 AND v.player.name == \"Yao Ming\") \\\n        OR NOT (v.player.name == \"Yao Ming\" OR v.player.name == \"Tim Duncan\") \\\n        RETURN v.player.name, v.player.age;\n...\nnebula> GO FROM \"player100\" \\\n        OVER follow \\\n        WHERE properties(edge).degree > 90 \\\n        OR properties($$).age != 33 \\\n        AND properties($$).name != \"Tony Parker\" \\\n        YIELD properties($$);\nFilter on properties\nUse vertex or edge properties to define conditions in WHERE clauses.\nFilter on a vertex property:nebula> MATCH (v:player)-[e]->(v2) \\\n        WHERE v2.player.age < 25 \\\n        RETURN v2.player.name, v2.player.age;\nnebula> GO FROM \"player100\" OVER follow \\\n        WHERE $^.player.age >= 42 \\\n        YIELD dst(edge);\nFilter on an edge property:nebula> MATCH (v:player)-[e]->() \\\n        WHERE e.start_year < 2000 \\\n        RETURN DISTINCT v.player.name, v.player.age;\n...\nnebula> GO FROM \"player100\" OVER follow \\\n        WHERE follow.degree > 90 \\\n        YIELD dst(edge);\nFilter on dynamically-calculated properties\nnebula> MATCH (v:player) \\\n        WHERE v[toLower(\"AGE\")] < 21 \\\n        RETURN v.player.name, v.player.age;\nFilter on existing properties\nnebula> MATCH (v:player) \\\n        WHERE exists(v.player.age) \\\n        RETURN v.player.name, v.player.age;\n...\nFilter on edge rank\nIn nGQL, if a group of edges has the same source vertex, destination vertex, and properties, the only thing that distinguishes them is the rank. Use rank conditions in WHERE clauses to filter such edges.\n# The following example creates test data.\nnebula> CREATE SPACE IF NOT EXISTS test (vid_type=FIXED_STRING(30));\nnebula> USE test;\nnebula> CREATE EDGE IF NOT EXISTS e1(p1 int);\nnebula> CREATE TAG IF NOT EXISTS person(p1 int);\nnebula> INSERT VERTEX person(p1) VALUES \"1\":(1);\nnebula> INSERT VERTEX person(p1) VALUES \"2\":(2);\nnebula> INSERT EDGE e1(p1) VALUES \"1\"->\"2\"@0:(10);\nnebula> INSERT EDGE e1(p1) VALUES \"1\"->\"2\"@1:(11);\nnebula> INSERT EDGE e1(p1) VALUES \"1\"->\"2\"@2:(12);\nnebula> INSERT EDGE e1(p1) VALUES \"1\"->\"2\"@3:(13);\nnebula> INSERT EDGE e1(p1) VALUES \"1\"->\"2\"@4:(14);\nnebula> INSERT EDGE e1(p1) VALUES \"1\"->\"2\"@5:(15);\nnebula> INSERT EDGE e1(p1) VALUES \"1\"->\"2\"@6:(16);\n# The following example use rank to filter edges and retrieves edges with a rank greater than 2.\nnebula> GO FROM \"1\" \\\n        OVER e1 \\\n        WHERE rank(edge) > 2 \\\n        YIELD src(edge), dst(edge), rank(edge) AS Rank, properties(edge).p1 | \\\n        ORDER BY $-.Rank DESC;\n# Filter edges by rank. Find follow edges with rank equal to 0.\nnebula> MATCH (v)-[e:follow]->() \\\n         WHERE rank(e)==0 \\\n         RETURN *;\n...\nFilter on pattern\nnebula> MATCH (v:player{name:\"Tim Duncan\"})-[e]->(t) \\\n        WHERE (v)-[e]->(t:team) \\\n        RETURN (v)-->();\nnebula> MATCH (v:player{name:\"Tim Duncan\"})-[e]->(t) \\\n        WHERE NOT (v)-[e]->(t:team) \\\n        RETURN (v)-->();\nFilter on strings\nUse STARTS WITH, ENDS WITH, or CONTAINS in WHERE clauses to match a specific part of a string. String matching is case-sensitive.\nSTARTS WITH\nSTARTS WITH will match the beginning of a string.\nThe following example uses STARTS WITH \"T\" to retrieve the information of players whose name starts with T.\nnebula> MATCH (v:player) \\\n        WHERE v.player.name STARTS WITH \"T\" \\\n        RETURN v.player.name, v.player.age;\nIf you use STARTS WITH \"t\" in the preceding statement, an empty set is returned because no name in the dataset starts with the lowercase t.\nnebula> MATCH (v:player) \\\n        WHERE v.player.name STARTS WITH \"t\" \\\n        RETURN v.player.name, v.player.age;\nEmpty set (time spent 5080/6474 us)\nENDS WITH\nENDS WITH will match the ending of a string.\nThe following example uses ENDS WITH \"r\" to retrieve the information of players whose name ends with r.\nnebula> MATCH (v:player) \\\n        WHERE v.player.name ENDS WITH \"r\" \\\n        RETURN v.player.name, v.player.age;\nCONTAINS\nCONTAINS will match a certain part of a string.\nThe following example uses CONTAINS \"Pa\" to match the information of players whose name contains Pa.\nnebula> MATCH (v:player) \\\n        WHERE v.player.name CONTAINS \"Pa\" \\\n        RETURN v.player.name, v.player.age;\nNegative string matching\nYou can use the boolean operator NOT to negate a string matching condition.\nnebula> MATCH (v:player) \\\n        WHERE NOT v.player.name ENDS WITH \"R\" \\\n        RETURN v.player.name, v.player.age;\n...\nFilter on lists\nMatch values in a list\nUse the IN operator to check if a value is in a specific list.\nnebula> MATCH (v:player) \\\n        WHERE v.player.age IN range(20,25) \\\n        RETURN v.player.name, v.player.age;\nnebula> LOOKUP ON player \\\n        WHERE player.age IN [25,28]  \\\n        YIELD properties(vertex).name, properties(vertex).age;\nMatch values not in a list\nUse NOT before IN to rule out the values in a list.\nnebula> MATCH (v:player) \\\n        WHERE v.player.age NOT IN range(20,25) \\\n        RETURN v.player.name AS Name, v.player.age AS Age \\\n        ORDER BY Age;\n...",
    "url": "8.clauses-and-options/where/",
    "type": "doc"
  },
  {
    "title": "YIELD",
    "content": "YIELD defines the output of an nGQL query.\nYIELD can lead a clause or a statement:\nA YIELD clause works in nGQL statements such as GO, FETCH, or LOOKUP and must be defined to return the result.\nA YIELD statement works in a composite query or independently.\nOpenCypher compatibility\nThis topic applies to native nGQL only. For the openCypher syntax, use RETURN.\nYIELD has different functions in openCypher and nGQL.\nIn openCypher, YIELD is used in the CALL[…YIELD] clause to specify the output of the procedure call.\nIn nGQL, YIELD works like RETURN in openCypher.\nYIELD clauses\nSyntax\nYIELD [DISTINCT] <col> [AS <alias>] [, <col> [AS <alias>] ...];\nParameter\nDescription\nDISTINCT\nAggregates the output and makes the statement return a distinct result set.\ncol\nA field to be returned. If no alias is set, col will be a column name in the output.\nalias\nAn alias for col. It is set after the keyword AS and will be a column name in the output.\nUse a YIELD clause in a statement\nUse YIELD with GO:nebula> GO FROM \"player100\" OVER follow \\\n        YIELD properties($$).name AS Friend, properties($$).age AS Age;\nUse YIELD with FETCH:nebula> FETCH PROP ON player \"player100\" \\\n        YIELD properties(vertex).name;\nUse YIELD with LOOKUP:nebula> LOOKUP ON player WHERE player.name == \"Tony Parker\" \\\n        YIELD properties(vertex).name, properties(vertex).age;\nYIELD statements\nSyntax\nYIELD [DISTINCT] <col> [AS <alias>] [, <col> [AS <alias>] ...]\n[WHERE <conditions>];\nParameter\nDescription\nDISTINCT\nAggregates the output and makes the statement return a distinct result set.\ncol\nA field to be returned. If no alias is set, col will be a column name in the output.\nalias\nAn alias for col. It is set after the keyword AS and will be a column name in the output.\nconditions\nConditions set in a WHERE clause to filter the output. For more information, see WHERE.\nUse a YIELD statement in a composite query\nIn a composite query, a YIELD statement accepts, filters, and modifies the result set of the preceding statement, and then outputs it.\nThe following query finds the players that \"player100\" follows and calculates their average age.\nnebula> GO FROM \"player100\" OVER follow \\\n        YIELD dst(edge) AS ID \\\n        | FETCH PROP ON player $-.ID \\\n        YIELD properties(vertex).age AS Age \\\n        | YIELD AVG($-.Age) as Avg_age, count(*)as Num_friends;\nThe following query finds the players that \"player101\" follows with the follow degrees greater than 90.\nnebula> $var1 = GO FROM \"player101\" OVER follow \\\n        YIELD properties(edge).degree AS Degree, dst(edge) as ID; \\\n        YIELD $var1.ID AS ID WHERE $var1.Degree > 90;\nThe following query finds the vertices in the player that are older than 30 and younger than 32, and returns the de-duplicate results.\nnebula> LOOKUP ON player  \\\n        WHERE player.age < 32 and player.age >30  \\\n        YIELD DISTINCT properties(vertex).age as v;\nUse a standalone YIELD statement\nA YIELD statement can calculate a valid expression and output the result.\nnebula> YIELD rand32(1, 6);\nnebula> YIELD \"Hel\" + \"\\tlo\" AS string1, \", World!\" AS string2;\nnebula> YIELD hash(\"Tim\") % 100;\nnebula> YIELD \\\n      CASE 2+3 \\\n      WHEN 4 THEN 0 \\\n      WHEN 5 THEN 1 \\\n      ELSE -1 \\\n      END \\\n      AS result;\nnebula> YIELD 1- -1;",
    "url": "8.clauses-and-options/yield/",
    "type": "doc"
  },
  {
    "title": "WITH",
    "content": "The WITH clause can retrieve the output from a query part, process it, and pass it to the next query part as the input.\nOpenCypher compatibility\nThis topic applies to openCypher syntax only.\nCombine statements and form a composite query\nUse a WITH clause to combine statements and transfer the output of a statement as the input of another statement.\nExample 1\nThe following statement:\nMatches a path.\nOutputs all the vertices on the path to a list with the nodes() function.\nUnwinds the list into rows.\nRemoves duplicated vertices and returns a set of distinct vertices.\nnebula> MATCH p=(v:player{name:\"Tim Duncan\"})--() \\\n        WITH nodes(p) AS n \\\n        UNWIND n AS n1 \\\n        RETURN DISTINCT n1;\nExample 2\nThe following statement:\nMatches the vertex with the VID player100.\nOutputs all the tags of the vertex into a list with the labels() function.\nUnwinds the list into rows.\nReturns the output.\nnebula> MATCH (v) \\\n        WHERE id(v)==\"player100\" \\\n        WITH labels(v) AS tags_unf \\\n        UNWIND tags_unf AS tags_f \\\n        RETURN tags_f;\nFilter composite queries\nWITH can work as a filter in the middle of a composite query.\nnebula> MATCH (v:player)-->(v2:player) \\\n        WITH DISTINCT v2 AS v2, v2.player.age AS Age \\\n        ORDER BY Age \\\n        WHERE Age<25 \\\n        RETURN v2.player.name AS Name, Age;\nProcess the output before using collect()\nUse a WITH clause to sort and limit the output before using collect() to transform the output into a list.\nnebula> MATCH (v:player) \\\n        WITH v.player.name AS Name \\\n        ORDER BY Name DESC \\\n        LIMIT 3 \\\n        RETURN collect(Name);\nUse with RETURN\nSet an alias using a WITH clause, and then output the result through a RETURN clause.\nnebula> WITH [1, 2, 3] AS `list` RETURN 3 IN `list` AS r;\nnebula> WITH 4 AS one, 3 AS two RETURN one > two AS result;",
    "url": "8.clauses-and-options/with/",
    "type": "doc"
  },
  {
    "title": "UNWIND",
    "content": "UNWIND transform a list into a sequence of rows.\nUNWIND can be used as an individual statement or as a clause within a statement.\nUNWIND statement\nSyntax\nUNWIND <list> AS <alias> <RETURN clause>;\nExamples\nTo transform a list.\nnebula> UNWIND [1,2,3] AS n RETURN n;\nUNWIND clause\nSyntax\nThe UNWIND clause in native nGQL statements.\n<statement> | UNWIND $-.<var> AS <alias> <|> <clause>;\nThe UNWIND clause in openCypher statements.\n<statement> UNWIND <list> AS <alias> <RETURN clause>；\nExamples\nTo transform a list of duplicates into a unique set of rows using WITH DISTINCT in a UNWIND clause.\n// Transform the list `[1,1,2,2,3,3]` into a unique set of rows, sort the rows, and then transform the rows into a list of unique values.\nnebula> WITH [1,1,2,2,3,3] AS n \\\n        UNWIND n AS r \\\n        WITH DISTINCT r AS r \\\n        ORDER BY r \\\n        RETURN collect(r);\nTo use an UNWIND clause in a MATCH statement.\n// Get a list of the vertices in the matched path, transform the list into a unique set of rows, and then transform the rows into a list. \nnebula> MATCH p=(v:player{name:\"Tim Duncan\"})--(v2) \\\n        WITH nodes(p) AS n \\\n        UNWIND n AS r \\\n        WITH DISTINCT r AS r \\\n        RETURN collect(r);\n|(\"player109\" :player{age: 34, name: \"Tiago Splitter\"}), (\"player108\" :player{age: 36, name: \"Boris Diaw\"})]           |  \nTo use an UNWIND clause in a GO statement.\n// Query the vertices in a list for the corresponding edges with a specified statement.\nnebula> YIELD ['player101', 'player100'] AS a | UNWIND $-.a AS  b | GO FROM $-.b OVER follow YIELD edge AS e;\nTo use an UNWIND clause in a LOOKUP statement.\n// Find all the properties of players whose age is greater than 46, get a list of unique properties, and then transform the list into rows. \nnebula> LOOKUP ON player \\\n        WHERE player.age > 46 \\\n        YIELD DISTINCT keys(vertex) as p | UNWIND $-.p as a | YIELD $-.a AS a;\nTo use an UNWIND clause in a FETCH statement. \n// Query player101 for all tags related to player101, get a list of the tags and then transform the list into rows.\nnebula> CREATE TAG hero(like string, height int);\n        INSERT VERTEX hero(like, height) VALUES \"player101\":(\"deep\", 182);\n        FETCH PROP ON * \"player101\" \\\n        YIELD tags(vertex) as t | UNWIND $-.t as a | YIELD $-.a AS a;\nTo use an UNWIND clause in a GET SUBGRAPH statement. \n// Get the subgraph including outgoing and incoming serve edges within 0~2 hops from/to player100, and transform the result into rows.\nnebula> GET SUBGRAPH 2 STEPS FROM \"player100\" BOTH serve \\\n        YIELD edges as e | UNWIND $-.e as a | YIELD $-.a AS a;\nTo use an UNWIND clause in a FIND PATH statement.\n// Find all the vertices in the shortest path from player101 to team204 along the serve edge, and transform the result into rows. \nnebula> FIND SHORTEST PATH FROM \"player101\" TO \"team204\" OVER serve \\\n        YIELD path as p | YIELD nodes($-.p) AS nodes | UNWIND $-.nodes AS a | YIELD $-.a AS a;",
    "url": "8.clauses-and-options/unwind/",
    "type": "doc"
  },
  {
    "title": "CREATE SPACE",
    "content": "Graph spaces are used to store data in a physically isolated way in NebulaGraph, which is similar to the database concept in MySQL. The CREATE SPACE statement can create a new graph space or clone the schema of an existing graph space.\nPrerequisites\nOnly the God role can use the CREATE SPACE statement. For more information, see AUTHENTICATION.\nSyntax\nCreate graph spaces\nCREATE SPACE [IF NOT EXISTS] <graph_space_name> (\n    [partition_num = <partition_number>,]\n    [replica_factor = <replica_number>,]\n    vid_type = {FIXED_STRING(<N>) | INT[64]}\n    [COMMENT = '<comment>'];\nParameter\nDescription\nIF NOT EXISTS\nDetects if the related graph space exists. If it does not exist, a new one will be created. The graph space existence detection here only compares the graph space name (excluding properties).\n<graph_space_name>\n1. Uniquely identifies a graph space in a NebulaGraph instance. 2. Space names cannot be modified after they are set. 3. Space names cannot start with a number; they support 1-4 byte UTF-8 encoded characters, including English letters (case sensitive), numbers, Chinese characters, etc., but do not include special characters other than underscores. To use special characters, reserved keywords or starting with a number, quote them with backticks (`) and cannot use periods (.). For more information, see Keywords and reserved words. Note: If you name a space in Chinese and encounter a SyntaxError, you need to quote the Chinese characters with backticks (`).\npartition_num\nSpecifies the number of partitions in each replica. The suggested value is 20 times (2 times for HDD) the number of the hard disks in the cluster. For example, if you have three hard disks in the cluster, we recommend that you set 60 partitions. The default value is 100.\nreplica_factor\nSpecifies the number of replicas in the cluster. The suggested number is 3 in a production environment and 1 in a test environment. The replica number must be an odd number for the need of quorum-based voting. The default value is 1.\nvid_type\nA required parameter. Specifies the VID type in a graph space. Available values are FIXED_STRING(N) and INT64. INT equals to INT64. `FIXED_STRING(<N>) specifies the VID as a string, while INT64 specifies it as an integer. N represents the maximum length of the VIDs. If you set a VID that is longer than N bytes, NebulaGraph throws an error. Note, for UTF-8 chars, the length may vary in different cases, i.e. a UTF-8 Chinese char is 3 byte, this means 11 Chinese chars(length-33) will exeed a FIXED_STRING(32) vid defination.\nCOMMENT\nThe remarks of the graph space. The maximum length is 256 bytes. By default, there is no comments on a space.\nClone graph spaces\nCREATE SPACE [IF NOT EXISTS] <new_graph_space_name> AS <old_graph_space_name>;\nParameter\nDescription\nIF NOT EXISTS\nDetects if the new graph space exists. If it does not exist, the new one will be created. The graph space existence detection here only compares the graph space name (excluding properties).\n<new_graph_space_name>\nThe name of the graph space that is newly created. The name of the graph space starts with a letter, supports 1 to 4 bytes UTF-8 encoded characters, such as English letters (case-sensitive), digits, and Chinese characters, but does not support special characters except underscores. For more information, see Keywords and reserved words. When a new graph space is created, the schema of the old graph space <old_graph_space_name> will be cloned, including its parameters (the number of partitions and replicas, etc.), Tag, Edge type and native indexes.\n<old_graph_space_name>\nThe name of the graph space that already exists.\nExamples\n# The following example creates a graph space with a specified VID type and the maximum length. Other fields still use the default values.\nnebula> CREATE SPACE IF NOT EXISTS my_space_1 (vid_type=FIXED_STRING(30));\n# The following example creates a graph space with a specified partition number, replica number, and VID type.\nnebula> CREATE SPACE IF NOT EXISTS my_space_2 (partition_num=15, replica_factor=1, vid_type=FIXED_STRING(30));\n#  The following example creates a graph space with a specified partition number, replica number, and VID type, and adds a comment on it.\nnebula> CREATE SPACE IF NOT EXISTS my_space_3 (partition_num=15, replica_factor=1, vid_type=FIXED_STRING(30)) comment=\"Test the graph space\";\n# Clone a graph space.\nnebula> CREATE SPACE IF NOT EXISTS my_space_4 as my_space_3;\nnebula> SHOW CREATE SPACE my_space_4;\nImplementation of the operation\nCheck partition distribution\nOn some large clusters, the partition distribution is possibly unbalanced because of the different startup times. You can run the following command to do a check of the machine distribution.\nnebula> SHOW HOSTS;\nTo balance the request loads, use the following command.\nnebula> BALANCE LEADER;\nnebula> SHOW HOSTS;",
    "url": "9.space-statements/1.create-space/",
    "type": "doc"
  },
  {
    "title": "USE",
    "content": "USE specifies a graph space as the current working graph space for subsequent queries.\nPrerequisites\nRunning the USE statement requires some privileges for the graph space. Otherwise, NebulaGraph throws an error.\nSyntax\nUSE <graph_space_name>;\nExamples\n# The following example creates two sample spaces.\nnebula> CREATE SPACE IF NOT EXISTS space1 (vid_type=FIXED_STRING(30));\nnebula> CREATE SPACE IF NOT EXISTS space2 (vid_type=FIXED_STRING(30));\n# The following example specifies space1 as the current working graph space.\nnebula> USE space1;\n# The following example specifies space2 as the current working graph space. Hereafter, you cannot read any data from space1, because these vertices and edges being traversed have no relevance with space1.\nnebula> USE space2;",
    "url": "9.space-statements/2.use-space/",
    "type": "doc"
  },
  {
    "title": "SHOW SPACES",
    "content": "SHOW SPACES lists all the graph spaces in the NebulaGraph examples.\nSyntax\nSHOW SPACES;\nExample\nnebula> SHOW SPACES;\nTo create graph spaces, see CREATE SPACE.",
    "url": "9.space-statements/3.show-spaces/",
    "type": "doc"
  },
  {
    "title": "DESCRIBE SPACE",
    "content": "DESCRIBE SPACE returns the information about the specified graph space.\nSyntax\nYou can use DESC instead of DESCRIBE for short.\nDESC[RIBE] SPACE <graph_space_name>;\nThe DESCRIBE SPACE statement is different from the SHOW SPACES statement. For details about SHOW SPACES, see SHOW SPACES.\nExample\nnebula> DESCRIBE SPACE basketballplayer;",
    "url": "9.space-statements/4.describe-space/",
    "type": "doc"
  },
  {
    "title": "CLEAR SPACE",
    "content": "CLEAR SPACE deletes the vertices and edges in a graph space, but does not delete the graph space itself and the schema information.\nPermission requirements\nOnly the God role has the permission to run CLEAR SPACE.\nCaution\nOnce cleared, the data CANNOT be recovered. Use CLEAR SPACE with caution.\nCLEAR SPACE is not an atomic operation. If an error occurs, re-run CLEAR SPACE to avoid data remaining.\nThe larger the amount of data in the graph space, the longer it takes to clear it. If the execution fails due to client connection timeout, increase the value of the storage_client_timeout_ms parameter in the Graph Service configuration.\nDuring the execution of CLEAR SPACE, writing data into the graph space is not automatically prohibited. Such write operations can result in incomplete data clearing, and the residual data can be damaged.\nSyntax\nCLEAR SPACE [IF EXISTS] <space_name>;\nParameter/Option\nDescription\nIF EXISTS\nCheck whether the graph space to be cleared exists. If it exists, continue to clear it. If it does not exist, the execution finishes, and a message indicating that the execution succeeded is displayed. If IF EXISTS is not set and the graph space does not exist, the CLEAR SPACE statement fails to execute, and an error occurs.\nspace_name\nThe name of the space to be cleared.\nExample:\nCLEAR SPACE basketballplayer;\nData reserved\nCLEAR SPACE does not delete the following data in a graph space:\nTag information.\nEdge type information.\nThe metadata of native indexes and full-text indexes.\nThe following example shows what CLEAR SPACE deletes and reserves.\n# Enter the graph space basketballplayer.\nnebula [(none)]> use basketballplayer;\nExecution succeeded\n# List tags and Edge types.\nnebula[basketballplayer]> SHOW TAGS;\nGot 2 rows\nnebula[basketballplayer]> SHOW EDGES;\nGot 2 rows\n# Submit a job to make statistics of the graph space.\nnebula[basketballplayer]> SUBMIT JOB STATS;\nGot 1 rows\n# Check the statistics.\nnebula[basketballplayer]> SHOW STATS;\nGot 6 rows\n# List tag indexes.\nnebula[basketballplayer]> SHOW TAG INDEXES;\nGot 2 rows\n# ----------------------- Dividing line for CLEAR SPACE -----------------------\n# Run CLEAR SPACE to clear the graph space basketballplayer.\nnebula[basketballplayer]> CLEAR SPACE basketballplayer;\nExecution succeeded\n# Update the statistics.\nnebula[basketballplayer]> SUBMIT JOB STATS;\nGot 1 rows\n# Check the statistics. The tags and edge types still exist, but all the vertices and edges are gone.\nnebula[basketballplayer]> SHOW STATS;\nGot 6 rows\n# Try to list the tag indexes. They still exist.\nnebula[basketballplayer]> SHOW TAG INDEXES;\nGot 2 rows (time spent 523/978 us)",
    "url": "9.space-statements/6.clear-space/",
    "type": "doc"
  },
  {
    "title": "DROP SPACE",
    "content": "DROP SPACE deletes the specified graph space and everything in it.\nPrerequisites\nOnly the God role can use the DROP SPACE statement. For more information, see AUTHENTICATION.\nSyntax\nDROP SPACE [IF EXISTS] <graph_space_name>;\nYou can use the IF EXISTS keywords when dropping spaces. These keywords automatically detect if the related graph space exists. If it exists, it will be deleted. Otherwise, no graph space will be deleted.\nFAQ\nQ: Why is my disk space not freed after executing the 'DROP SPACE' statement and deleting a graph space?\nA: For NebulaGraph version earlier than 3.1.0, DROP SPACE can only delete the specified logic graph space and does not delete the files and directories on the disk. To delete the files and directories on the disk, manually delete the corresponding file path. The file path is located in <nebula_graph_install_path>/data/storage/nebula/<space_id>. The <space_id> can be viewed via DESCRIBE SPACE {space_name}.",
    "url": "9.space-statements/5.drop-space/",
    "type": "doc"
  },
  {
    "title": "CREATE TAG",
    "content": "CREATE TAG creates a tag with the given name in a graph space.\nOpenCypher compatibility\nTags in nGQL are similar to labels in openCypher. But they are also quite different. For example, the ways to create them are different.\nIn openCypher, labels are created together with vertices in CREATE statements.\nIn nGQL, tags are created separately using CREATE TAG statements. Tags in nGQL are more like tables in MySQL.\nPrerequisites\nRunning the CREATE TAG statement requires some privileges for the graph space. Otherwise, NebulaGraph throws an error.\nSyntax\nTo create a tag in a specific graph space, you must specify the current working space with the USE statement.\nCREATE TAG [IF NOT EXISTS] <tag_name>\n      <prop_name> <data_type> [NULL | NOT NULL] [DEFAULT <default_value>] [COMMENT '<comment>']\n      [{, <prop_name> <data_type> [NULL | NOT NULL] [DEFAULT <default_value>] [COMMENT '<comment>']} ...] \n    [TTL_DURATION = <ttl_duration>]\n    [TTL_COL = <prop_name>]\n    [COMMENT = '<comment>'];\nParameter\nDescription\nIF NOT EXISTS\nDetects if the tag that you want to create exists. If it does not exist, a new one will be created. The tag existence detection here only compares the tag names (excluding properties).\n<tag_name>\n1. Each tag name in the graph space must be unique. 2. Tag names cannot be modified after they are set.3. Tag names cannot start with a number; they support 1-4 byte UTF-8 encoded characters, including English letters (case sensitive), numbers, Chinese characters, etc., but do not support special characters other than underscores. To use special characters, reserved keywords, or start with a number in a tag name, enclose them in backticks (`), and do not use periods (.) in a tag name. For more information, see Keywords and reserved words. Note: If you name a tag in Chinese and encounter a SyntaxError, you need to quote the Chinese characters with backticks (`).\n<prop_name>\nThe name of the property. It must be unique for each tag. The rules for permitted property names are the same as those for tag names.\n<data_type>\nShows the data type of each property. For a full description of the property data types, see Data types and Boolean.\nNULL \\| NOT NULL\nSpecifies if the property supports NULL | NOT NULL. The default value is NULL.\nDEFAULT\nSpecifies a default value for a property. The default value can be a literal value or an expression supported by NebulaGraph. If no value is specified, the default value is used when inserting a new vertex.\nCOMMENT\nThe remarks of a certain property or the tag itself. The maximum length is 256 bytes. By default, there will be no comments on a tag.\nTTL_DURATION\nSpecifies the life cycle for the property. The property that exceeds the specified TTL expires. The expiration threshold is the TTL_COL value plus the TTL_DURATION. The default value of TTL_DURATION is 0. It means the data never expires.\nTTL_COL\nSpecifies the property to set a timeout on. The data type of the property must be int or timestamp. A tag can only specify one field as TTL_COL. For more information on TTL, see TTL options.\nExamples\nnebula> CREATE TAG IF NOT EXISTS player(name string, age int);\n# The following example creates a tag with no properties.\nnebula> CREATE TAG IF NOT EXISTS no_property(); \n# The following example creates a tag with a default value.\nnebula> CREATE TAG IF NOT EXISTS player_with_default(name string, age int DEFAULT 20);\n# In the following example, the TTL of the create_time field is set to be 100 seconds.\nnebula> CREATE TAG IF NOT EXISTS woman(name string, age int, \\\n        married bool, salary double, create_time timestamp) \\\n        TTL_DURATION = 100, TTL_COL = \"create_time\";\nImplementation of the operation\nTrying to use a newly created tag may fail because the creation of the tag is implemented asynchronously. To make sure the follow-up operations work as expected, Wait for two heartbeat cycles, i.e., 20 seconds.\nTo change the heartbeat interval, modify the heartbeat_interval_secs parameter in the configuration files for all services.",
    "url": "10.tag-statements/1.create-tag/",
    "type": "doc"
  },
  {
    "title": "DROP TAG",
    "content": "DROP TAG drops a tag with the given name in the current working graph space.\nA vertex can have one or more tags.\nIf a vertex has only one tag, the vertex CANNOT be accessed after you drop it. The vertex will be dropped in the next compaction. But its edges are available, this operation will result in dangling edges.\nIf a vertex has multiple tags, the vertex is still accessible after you drop one of them. But all the properties defined by this dropped tag CANNOT be accessed.\nThis operation only deletes the Schema data. All the files or directories in the disk will not be deleted directly until the next compaction.\nPrerequisites\nRunning the DROP TAG statement requires some privileges for the graph space. Otherwise, NebulaGraph throws an error.\nBefore you drop a tag, make sure that the tag does not have any indexes. Otherwise, the conflict error ([ERROR (-1005)]: Conflict!) will be returned when you run the DROP TAG statement. To drop an index, see DROP INDEX.\nSyntax\nDROP TAG [IF EXISTS] <tag_name>;\nIF NOT EXISTS: Detects if the tag that you want to drop exists. Only when it exists will it be dropped.\ntag_name: Specifies the tag name that you want to drop. You can drop only one tag in one statement.\nExample\nnebula> CREATE TAG IF NOT EXISTS test(p1 string, p2 int);\nnebula> DROP TAG test;",
    "url": "10.tag-statements/2.drop-tag/",
    "type": "doc"
  },
  {
    "title": "ALTER TAG",
    "content": "ALTER TAG alters the structure of a tag with the given name in a graph space. You can add or drop properties, and change the data type of an existing property. You can also set a TTL (Time-To-Live) on a property, or change its TTL duration.\nNotes\nRunning the ALTER TAG statement requires some privileges for the graph space. Otherwise, NebulaGraph throws an error.\nBefore you alter properties for a tag, make sure that the properties are not indexed. If the properties contain any indexes, the conflict error [ERROR (-1005)]: Conflict! will occur when you ALTER TAG. For more information on dropping an index, see DROP INDEX.\nThe property name must be unique in a tag. If you add a property with the same name as an existing property or a dropped property, the operation fails.\nSyntax\nALTER TAG <tag_name>\n    <alter_definition> [[, alter_definition] ...]\n    [ttl_definition [, ttl_definition] ... ]\n    [COMMENT '<comment>'];\nalter_definition:\n| ADD    (prop_name data_type [NULL | NOT NULL] [DEFAULT <default_value>] [COMMENT '<comment>'])\n| DROP   (prop_name)\n| CHANGE (prop_name data_type [NULL | NOT NULL] [DEFAULT <default_value>] [COMMENT '<comment>'])\nttl_definition:\n    TTL_DURATION = ttl_duration, TTL_COL = prop_name\ntag_name: Specifies the tag name that you want to alter. You can alter only one tag in one statement. Before you alter a tag, make sure that the tag exists in the current working graph space. If the tag does not exist, an error will occur when you alter it.\nMultiple ADD, DROP, and CHANGE clauses are permitted in a single ALTER TAG statement, separated by commas.\nWhen a property value is set to NOT NULL using ADD or CHANGE, a default value must be specified for the property, that is, the value of DEFAULT must be specified.\nWhen using CHANGE to modify the data type of a property:\nOnly the length of a FIXED_STRING or an INT can be increased. The length of a STRING or an INT cannot be decreased.\nOnly the data type conversions from FIXED_STRING to STRING and from FLOAT to DOUBLE are allowed.\nExamples\nnebula> CREATE TAG IF NOT EXISTS t1 (p1 string, p2 int);\nnebula> ALTER TAG t1 ADD (p3 int32, fixed_string(10));\nnebula> ALTER TAG t1 TTL_DURATION = 2, TTL_COL = \"p2\";\nnebula> ALTER TAG t1 COMMENT = 'test1';\nnebula> ALTER TAG t1 ADD (p5 double NOT NULL DEFAULT 0.4 COMMENT 'p5') COMMENT='test2';\n// Change the data type of p3 in the TAG t1 from INT32 to INT64, and that of p4 from FIXED_STRING(10) to STRING.\nnebula> ALTER TAG t1 CHANGE (p3 int64, p4 string);\n[ERROR(-1005)]: Unsupported!\nImplementation of the operation\nTrying to use a newly altered tag may fail because the alteration of the tag is implemented asynchronously. To make sure the follow-up operations work as expected, Wait for two heartbeat cycles, i.e., 20 seconds.\nTo change the heartbeat interval, modify the heartbeat_interval_secs parameter in the configuration files for all services.",
    "url": "10.tag-statements/3.alter-tag/",
    "type": "doc"
  },
  {
    "title": "SHOW TAGS",
    "content": "The SHOW TAGS statement shows the name of all tags in the current graph space.\nYou do not need any privileges for the graph space to run the SHOW TAGS statement. But the returned results are different based on role privileges.\nSyntax\nSHOW TAGS;\nExamples\nnebula> SHOW TAGS;",
    "url": "10.tag-statements/4.show-tags/",
    "type": "doc"
  },
  {
    "title": "DESCRIBE TAG",
    "content": "DESCRIBE TAG returns the information about a tag with the given name in a graph space, such as field names, data type, and so on.\nPrerequisite\nRunning the DESCRIBE TAG statement requires some privileges for the graph space. Otherwise, NebulaGraph throws an error.\nSyntax\nDESC[RIBE] TAG <tag_name>;\nYou can use DESC instead of DESCRIBE for short.\nExample\nnebula> DESCRIBE TAG player;",
    "url": "10.tag-statements/5.describe-tag/",
    "type": "doc"
  },
  {
    "title": "DELETE TAG",
    "content": "DELETE TAG deletes a tag with the given name on a specified vertex.\nPrerequisites\nRunning the DELETE TAG statement requires some privileges for the graph space. Otherwise, NebulaGraph throws an error.\nSyntax\nDELETE TAG <tag_name_list> FROM <VID>;\ntag_name_list: Specifies the name of the tag. Multiple tags are separated with commas (,). * means all tags.\nVID: Specifies the VID of the tag to delete.\nExample\nnebula> CREATE TAG IF NOT EXISTS test1(p1 string, p2 int);\nnebula> CREATE TAG IF NOT EXISTS test2(p3 string, p4 int);\nnebula> INSERT VERTEX test1(p1, p2),test2(p3, p4) VALUES \"test\":(\"123\", 1, \"456\", 2);\nnebula> FETCH PROP ON * \"test\" YIELD vertex AS v;\nnebula> DELETE TAG test1 FROM \"test\";\nnebula> FETCH PROP ON * \"test\" YIELD vertex AS v;\nnebula> DELETE TAG * FROM \"test\";\nnebula> FETCH PROP ON * \"test\" YIELD vertex AS v;",
    "url": "10.tag-statements/6.delete-tag/",
    "type": "doc"
  },
  {
    "title": "Add and delete tags",
    "content": "OpenCypher has the features of SET label and REMOVE label to speed up the process of querying or labeling.\nNebulaGraph achieves the same operations by creating and inserting tags to an existing vertex, which can quickly query vertices based on the tag name. Users can also run DELETE TAG to delete some vertices that are no longer needed.\nExamples\nFor example, in the basketballplayer data set, some basketball players are also team shareholders. Users can create an index for the shareholder tag shareholder for quick search. If the player is no longer a shareholder, users can delete the shareholder tag of the corresponding player by DELETE TAG.\n//This example creates the shareholder tag and index.\nnebula> CREATE TAG IF NOT EXISTS shareholder();\nnebula> CREATE TAG INDEX IF NOT EXISTS shareholder_tag on shareholder();\n//This example adds a tag on the vertex.\nnebula> INSERT VERTEX shareholder() VALUES \"player100\":();\nnebula> INSERT VERTEX shareholder() VALUES \"player101\":();\n//This example queries all the shareholders.\nnebula> MATCH (v:shareholder) RETURN v;\nnebula> LOOKUP ON shareholder YIELD id(vertex);\n//In this example, the \"player100\" is no longer a shareholder.\nnebula> DELETE TAG shareholder FROM \"player100\";\nnebula> LOOKUP ON shareholder YIELD id(vertex);",
    "url": "10.tag-statements/improve-query-by-tag-index/",
    "type": "doc"
  },
  {
    "title": "CREATE EDGE",
    "content": "CREATE EDGE creates an edge type with the given name in a graph space.\nOpenCypher compatibility\nEdge types in nGQL are similar to relationship types in openCypher. But they are also quite different. For example, the ways to create them are different.\nIn openCypher, relationship types are created together with vertices in CREATE statements.\nIn nGQL, edge types are created separately using CREATE EDGE statements. Edge types in nGQL are more like tables in MySQL.\nPrerequisites\nRunning the CREATE EDGE statement requires some privileges for the graph space. Otherwise, NebulaGraph throws an error.\nSyntax\nTo create an edge type in a specific graph space, you must specify the current working space with the USE statement.\nCREATE EDGE [IF NOT EXISTS] <edge_type_name>\n      <prop_name> <data_type> [NULL | NOT NULL] [DEFAULT <default_value>] [COMMENT '<comment>']\n      [{, <prop_name> <data_type> [NULL | NOT NULL] [DEFAULT <default_value>] [COMMENT '<comment>']} ...] \n    [TTL_DURATION = <ttl_duration>]\n    [TTL_COL = <prop_name>]\n    [COMMENT = '<comment>'];\nParameter\nDescription\nIF NOT EXISTS\nDetects if the edge type that you want to create exists. If it does not exist, a new one will be created. The edge type existence detection here only compares the edge type names (excluding properties).\n<edge_type_name>\n1. The edge type name must be unique in a graph space. 2. Once the edge type name is set, it can not be altered. 3. Edge type names cannot start with a number; they support 1-4 byte UTF-8 encoded characters, including English letters (case sensitive), numbers, Chinese characters, etc., but do not include special characters other than underscores. To use special characters, reserved keywords or starting with a number, quote them with backticks (`) and cannot use periods (.). For more information, see Keywords and reserved words. Note: If you name an edge type in Chinese and encounter a SyntaxError, you need to quote the Chinese characters with backticks (`).\n<prop_name>\nThe name of the property. It must be unique for each edge type. The rules for permitted property names are the same as those for edge type names.\n<data_type>\nShows the data type of each property. For a full description of the property data types, see Data types and Boolean.\nNULL \\| NOT NULL\nSpecifies if the property supports NULL | NOT NULL. The default value is NULL. DEFAULT must be specified if NOT NULL is set.\nDEFAULT\nSpecifies a default value for a property. The default value can be a literal value or an expression supported by NebulaGraph. If no value is specified, the default value is used when inserting a new edge.\nCOMMENT\nThe remarks of a certain property or the edge type itself. The maximum length is 256 bytes. By default, there will be no comments on an edge type.\nTTL_DURATION\nSpecifies the life cycle for the property. The property that exceeds the specified TTL expires. The expiration threshold is the TTL_COL value plus the TTL_DURATION. The default value of TTL_DURATION is 0. It means the data never expires.\nTTL_COL\nSpecifies the property to set a timeout on. The data type of the property must be int or timestamp. An edge type can only specify one field as TTL_COL. For more information on TTL, see TTL options.\nExamples\nnebula> CREATE EDGE IF NOT EXISTS follow(degree int);\n# The following example creates an edge type with no properties.\nnebula> CREATE EDGE IF NOT EXISTS no_property();\n# The following example creates an edge type with a default value.\nnebula> CREATE EDGE IF NOT EXISTS follow_with_default(degree int DEFAULT 20);\n# In the following example, the TTL of the p2 field is set to be 100 seconds.\nnebula> CREATE EDGE IF NOT EXISTS e1(p1 string, p2 int, p3 timestamp) \\\n        TTL_DURATION = 100, TTL_COL = \"p2\";",
    "url": "11.edge-type-statements/1.create-edge/",
    "type": "doc"
  },
  {
    "title": "DROP EDGE",
    "content": "DROP EDGE drops an edge type with the given name in a graph space.\nAn edge can have only one edge type. After you drop it, the edge CANNOT be accessed. The edge will be deleted in the next compaction.\nThis operation only deletes the Schema data. All the files or directories in the disk will not be deleted directly until the next compaction.\nPrerequisites\nRunning the DROP EDGE statement requires some privileges for the graph space. Otherwise, NebulaGraph throws an error.\nBefore you drop an edge type, make sure that the edge type does not have any indexes. Otherwise, the conflict error ([ERROR (-1005)]: Conflict!) will be returned. To drop an index, see DROP INDEX.\nSyntax\nDROP EDGE [IF EXISTS] <edge_type_name>\nIF NOT EXISTS: Detects if the edge type that you want to drop exists. Only when it exists will it be dropped.\nedge_type_name: Specifies the edge type name that you want to drop. You can drop only one edge type in one statement.\nExample\nnebula> CREATE EDGE IF NOT EXISTS e1(p1 string, p2 int);\nnebula> DROP EDGE e1;",
    "url": "11.edge-type-statements/2.drop-edge/",
    "type": "doc"
  },
  {
    "title": "ALTER EDGE",
    "content": "ALTER EDGE alters the structure of an edge type with the given name in a graph space. You can add or drop properties, and change the data type of an existing property. You can also set a TTL (Time-To-Live) on a property, or change its TTL duration.\nNotes\nRunning the ALTER EDGE statement requires some privileges for the graph space. Otherwise, NebulaGraph throws an error.\nBefore you alter properties for an edge type, make sure that the properties are not indexed. If the properties contain any indexes, the conflict error [ERROR (-1005)]: Conflict! will occur when you ALTER EDGE. For more information on dropping an index, see DROP INDEX.\nThe property name must be unique in an edge type. If you add a property with the same name as an existing property or a dropped property, the operation fails.\nOnly the length of a FIXED_STRING or an INT can be increased.\nOnly the data type conversions from FIXED_STRING to STRING and from FLOAT to DOUBLE are allowed.\nSyntax\nALTER EDGE <edge_type_name>\n    <alter_definition> [, alter_definition] ...]\n    [ttl_definition [, ttl_definition] ... ]\n    [COMMENT = '<comment>'];\nalter_definition:\n| ADD    (prop_name data_type)\n| DROP   (prop_name)\n| CHANGE (prop_name data_type)\nttl_definition:\n    TTL_DURATION = ttl_duration, TTL_COL = prop_name\nedge_type_name: Specifies the edge type name that you want to alter. You can alter only one edge type in one statement. Before you alter an edge type, make sure that the edge type exists in the graph space. If the edge type does not exist, an error occurs when you alter it.\nMultiple ADD, DROP, and CHANGE clauses are permitted in a single ALTER EDGE statement, separated by commas.\nWhen a property value is set to NOT NULL using ADD or CHANGE, a default value must be specified for the property, that is, the value of DEFAULT must be specified.\nExample\nnebula> CREATE EDGE IF NOT EXISTS e1(p1 string, p2 int);\nnebula> ALTER EDGE e1 ADD (p3 int, p4 string);\nnebula> ALTER EDGE e1 TTL_DURATION = 2, TTL_COL = \"p2\";\nnebula> ALTER EDGE e1 COMMENT = 'edge1';\nImplementation of the operation\nTrying to use a newly altered edge type may fail because the alteration of the edge type is implemented asynchronously. To make sure the follow-up operations work as expected, Wait for two heartbeat cycles, i.e., 20 seconds.\nTo change the heartbeat interval, modify the heartbeat_interval_secs parameter in the configuration files for all services.",
    "url": "11.edge-type-statements/3.alter-edge/",
    "type": "doc"
  },
  {
    "title": "SHOW EDGES",
    "content": "SHOW EDGES shows all edge types in the current graph space.\nYou do not need any privileges for the graph space to run the SHOW EDGES statement. But the returned results are different based on role privileges.\nSyntax\nSHOW EDGES;\nExample\nnebula> SHOW EDGES;",
    "url": "11.edge-type-statements/4.show-edges/",
    "type": "doc"
  },
  {
    "title": "DESCRIBE EDGE",
    "content": "DESCRIBE EDGE returns the information about an edge type with the given name in a graph space, such as field names, data type, and so on.\nPrerequisites\nRunning the DESCRIBE EDGE statement requires some privileges for the graph space. Otherwise, NebulaGraph throws an error.\nSyntax\nDESC[RIBE] EDGE <edge_type_name>\nYou can use DESC instead of DESCRIBE for short.\nExample\nnebula> DESCRIBE EDGE follow;",
    "url": "11.edge-type-statements/5.describe-edge/",
    "type": "doc"
  },
  {
    "title": "INSERT VERTEX",
    "content": "The INSERT VERTEX statement inserts one or more vertices into a graph space in NebulaGraph.\nPrerequisites\nRunning the INSERT VERTEX statement requires some privileges for the graph space. Otherwise, NebulaGraph throws an error.\nSyntax\nINSERT VERTEX [IF NOT EXISTS] [tag_props, [tag_props] ...]\nVALUES VID: ([prop_value_list])\ntag_props:\n  tag_name ([prop_name_list])\nprop_name_list:\n   [prop_name [, prop_name] ...]\nprop_value_list:\n   [prop_value [, prop_value] ...] \nIF NOT EXISTS detects if the VID that you want to insert exists. If it does not exist, a new one will be inserted.\ntag_name denotes the tag (vertex type), which must be created before INSERT VERTEX. For more information, see CREATE TAG.\nprop_name_list contains the names of the properties on the tag.\nVID is the vertex ID. In NebulaGraph 2.0, string and integer VID types are supported. The VID type is set when a graph space is created. For more information, see CREATE SPACE.\nprop_value_list must provide the property values according to the prop_name_list. When the NOT NULL constraint is set for a given property, an error is returned if no property is given. When the default value for a property is NULL, you can omit to specify the property value. For details, see CREATE TAG.\nExamples are as follows.\nExamples\n# Insert a vertex without tag.\nnebula> INSERT VERTEX VALUES \"1\":();\n# The following examples create tag t1 with no property and inserts vertex \"10\" with no property.\nnebula> CREATE TAG IF NOT EXISTS t1();                   \nnebula> INSERT VERTEX t1() VALUES \"10\":(); \nnebula> CREATE TAG IF NOT EXISTS t2 (name string, age int);                \nnebula> INSERT VERTEX t2 (name, age) VALUES \"11\":(\"n1\", 12);\n#  In the following example, the insertion fails because \"a13\" is not int.\nnebula> INSERT VERTEX t2 (name, age) VALUES \"12\":(\"n1\", \"a13\"); \n# The following example inserts two vertices at one time.\nnebula> INSERT VERTEX t2 (name, age) VALUES \"13\":(\"n3\", 12), \"14\":(\"n4\", 8); \nnebula> CREATE TAG IF NOT EXISTS t3(p1 int);\nnebula> CREATE TAG IF NOT EXISTS t4(p2 string);\n# The following example inserts vertex \"21\" with two tags.\nnebula> INSERT VERTEX t3 (p1), t4(p2) VALUES \"21\": (321, \"hello\");\nA vertex can be inserted/written with new values multiple times. Only the last written values can be read.\n# The following examples insert vertex \"11\" with new values for multiple times.\nnebula> INSERT VERTEX t2 (name, age) VALUES \"11\":(\"n2\", 13);\nnebula> INSERT VERTEX t2 (name, age) VALUES \"11\":(\"n3\", 14);\nnebula> INSERT VERTEX t2 (name, age) VALUES \"11\":(\"n4\", 15);\nnebula> FETCH PROP ON t2 \"11\" YIELD properties(vertex);\nnebula> CREATE TAG IF NOT EXISTS t5(p1 fixed_string(5) NOT NULL, p2 int, p3 int DEFAULT NULL);\nnebula> INSERT VERTEX t5(p1, p2, p3) VALUES \"001\":(\"Abe\", 2, 3);\n# In the following example, the insertion fails because the value of p1 cannot be NULL.\nnebula> INSERT VERTEX t5(p1, p2, p3) VALUES \"002\":(NULL, 4, 5);\n[ERROR (-1009)]: SemanticError: No schema found for `t5'\n# In the following example, the value of p3 is the default NULL.\nnebula> INSERT VERTEX t5(p1, p2) VALUES \"003\":(\"cd\", 5);\nnebula> FETCH PROP ON t5 \"003\" YIELD properties(vertex);\n# In the following example, the allowed maximum length of p1 is 5.\nnebula> INSERT VERTEX t5(p1, p2) VALUES \"004\":(\"shalalalala\", 4);\nnebula> FETCH PROP on t5 \"004\" YIELD properties(vertex);\nIf you insert a vertex that already exists with IF NOT EXISTS, there will be no modification.\n# The following example inserts vertex \"1\".\nnebula> INSERT VERTEX t2 (name, age) VALUES \"1\":(\"n2\", 13);\n# Modify vertex \"1\" with IF NOT EXISTS. But there will be no modification as vertex \"1\" already exists.\nnebula> INSERT VERTEX IF NOT EXISTS t2 (name, age) VALUES \"1\":(\"n3\", 14);\nnebula> FETCH PROP ON t2 \"1\" YIELD properties(vertex);",
    "url": "12.vertex-statements/1.insert-vertex/",
    "type": "doc"
  },
  {
    "title": "DELETE VERTEX",
    "content": "By default, the DELETE VERTEX statement deletes vertices but the incoming and outgoing edges of the vertices.\nThe DELETE VERTEX statement deletes one vertex or multiple vertices at a time. You can use DELETE VERTEX together with pipes. For more information about pipe, see Pipe operator.\nSyntax\nDELETE VERTEX <vid> [, <vid> ...] [WITH EDGE];\nWITH EDGE: deletes vertices and the related incoming and outgoing edges of the vertices.\nExamples\nThis query deletes the vertex whose ID is \"team1\".\n# Delete the vertex whose VID is `team1` but the related incoming and outgoing edges are not deleted.\nnebula> DELETE VERTEX \"team1\";\n# Delete the vertex whose VID is `team1` and the related incoming and outgoing edges.\nnebula> DELETE VERTEX \"team1\" WITH EDGE;\nThis query shows that you can use DELETE VERTEX together with pipe to delete vertices.\nnebula> GO FROM \"player100\" OVER serve WHERE properties(edge).start_year == \"2021\" YIELD dst(edge) AS id | DELETE VERTEX $-.id;\nProcess of deleting vertices\nOnce NebulaGraph deletes the vertices, all edges (incoming and outgoing edges) of the target vertex will become dangling edges. When NebulaGraph deletes the vertices WITH EDGE, NebulaGraph traverses the incoming and outgoing edges related to the vertices and deletes them all. Then NebulaGraph deletes the vertices.",
    "url": "12.vertex-statements/4.delete-vertex/",
    "type": "doc"
  },
  {
    "title": "UPDATE VERTEX",
    "content": "The UPDATE VERTEX statement updates properties on tags of a vertex.\nIn NebulaGraph, UPDATE VERTEX supports compare-and-set (CAS).\nSyntax\nUPDATE VERTEX ON <tag_name> <vid>\nSET <update_prop>\n[WHEN <condition>]\n[YIELD <output>]\nParameter\nRequired\nDescription\nExample\nON <tag_name>\nYes\nSpecifies the tag of the vertex. The properties to be updated must be on this tag.\nON player\n<vid>\nYes\nSpecifies the ID of the vertex to be updated.\n\"player100\"\nSET <update_prop>\nYes\nSpecifies the properties to be updated and how they will be updated.\nSET age = age +1\nWHEN <condition>\nNo\nSpecifies the filter conditions. If <condition> evaluates to false, the SET clause will not take effect.\nWHEN name == \"Tim\"\nYIELD <output>\nNo\nSpecifies the output format of the statement.\nYIELD name AS Name\nExample\n// This query checks the properties of vertex \"player101\".\nnebula> FETCH PROP ON player \"player101\" YIELD properties(vertex);\n// This query updates the age property and returns name and the new age.\nnebula> UPDATE VERTEX ON player \"player101\" \\\n        SET age = age + 2 \\\n        WHEN name == \"Tony Parker\" \\\n        YIELD name AS Name, age AS Age;",
    "url": "12.vertex-statements/2.update-vertex/",
    "type": "doc"
  },
  {
    "title": "UPSERT VERTEX",
    "content": "The UPSERT statement is a combination of UPDATE and INSERT. You can use UPSERT VERTEX to update the properties of a vertex if it exists or insert a new vertex if it does not exist.\nThe performance of UPSERT is much lower than that of INSERT because UPSERT is a read-modify-write serialization operation at the partition level.\nSyntax\nUPSERT VERTEX ON <tag> <vid>\nSET <update_prop>\n[WHEN <condition>]\n[YIELD <output>]\nParameter\nRequired\nDescription\nExample\nON <tag>\nYes\nSpecifies the tag of the vertex. The properties to be updated must be on this tag.\nON player\n<vid>\nYes\nSpecifies the ID of the vertex to be updated or inserted.\n\"player100\"\nSET <update_prop>\nYes\nSpecifies the properties to be updated and how they will be updated.\nSET age = age +1\nWHEN <condition>\nNo\nSpecifies the filter conditions.\nWHEN name == \"Tim\"\nYIELD <output>\nNo\nSpecifies the output format of the statement.\nYIELD name AS Name\nInsert a vertex if it does not exist\nIf a vertex does not exist, it is created no matter the conditions in the WHEN clause are met or not, and the SET clause always takes effect. The property values of the new vertex depend on:\nHow the SET clause is defined.\nWhether the property has a default value.\nFor example, if:\nThe vertex to be inserted will have properties name and age based on the tag player.\nThe SET clause specifies that age = 30.\nThen the property values in different cases are listed as follows:\nAre WHEN conditions met\nIf properties have default values\nValue of name\nValue of age\nYes\nYes\nThe default value\n30\nYes\nNo\nNULL\n30\nNo\nYes\nThe default value\n30\nNo\nNo\nNULL\n30\nHere are some examples:\n// This query checks if the following three vertices exist. The result \"Empty set\" indicates that the vertices do not exist.\nnebula> FETCH PROP ON * \"player666\", \"player667\", \"player668\" YIELD properties(vertex);\nEmpty set\nnebula> UPSERT VERTEX ON player \"player666\" \\\n        SET age = 30 \\\n        WHEN name == \"Joe\" \\\n        YIELD name AS Name, age AS Age;\nnebula> UPSERT VERTEX ON player \"player666\" \\\n        SET age = 31 \\\n        WHEN name == \"Joe\" \\\n        YIELD name AS Name, age AS Age;\nnebula> UPSERT VERTEX ON player \"player667\" \\\n        SET age = 31 \\\n        YIELD name AS Name, age AS Age;\nnebula> UPSERT VERTEX ON player \"player668\" \\\n        SET name = \"Amber\", age = age + 1 \\\n        YIELD name AS Name, age AS Age;\nIn the last query of the preceding examples, since age has no default value, when the vertex is created, age is NULL, and age = age + 1 does not take effect. But if age has a default value, age = age + 1 will take effect. For example:\nnebula> CREATE TAG IF NOT EXISTS player_with_default(name string, age int DEFAULT 20);\nExecution succeeded\nnebula> UPSERT VERTEX ON player_with_default \"player101\" \\\n        SET age = age + 1 \\\n        YIELD name AS Name, age AS Age;\nUpdate a vertex if it exists\nIf the vertex exists and the WHEN conditions are met, the vertex is updated.\nnebula> FETCH PROP ON player \"player101\" YIELD properties(vertex);\nnebula> UPSERT VERTEX ON player \"player101\" \\\n        SET age = age + 2 \\\n        WHEN name == \"Tony Parker\" \\\n        YIELD name AS Name, age AS Age;\nIf the vertex exists and the WHEN conditions are not met, the update does not take effect.\nnebula> FETCH PROP ON player \"player101\" YIELD properties(vertex);\nnebula> UPSERT VERTEX ON player \"player101\" \\\n        SET age = age + 2 \\\n        WHEN name == \"Someone else\" \\\n        YIELD name AS Name, age AS Age;",
    "url": "12.vertex-statements/3.upsert-vertex/",
    "type": "doc"
  },
  {
    "title": "INSERT EDGE",
    "content": "The INSERT EDGE statement inserts an edge or multiple edges into a graph space from a source vertex (given by src_vid) to a destination vertex (given by dst_vid) with a specific rank in NebulaGraph.\nWhen inserting an edge that already exists, INSERT EDGE overrides the edge.\nSyntax\nINSERT EDGE [IF NOT EXISTS] <edge_type> ( <prop_name_list> ) VALUES \n<src_vid> -> <dst_vid>[@<rank>] : ( <prop_value_list> )\n[, <src_vid> -> <dst_vid>[@<rank>] : ( <prop_value_list> ), ...];\n<prop_name_list> ::=\n  [ <prop_name> [, <prop_name> ] ...]\n<prop_value_list> ::=\n  [ <prop_value> [, <prop_value> ] ...]\nIF NOT EXISTS detects if the edge that you want to insert exists. If it does not exist, a new one will be inserted.\n<edge_type> denotes the edge type, which must be created before INSERT EDGE. Only one edge type can be specified in this statement.\n<prop_name_list> is the property name list in the given <edge_type>.\nsrc_vid is the VID of the source vertex. It specifies the start of an edge.\ndst_vid is the VID of the destination vertex. It specifies the end of an edge.\nrank is optional. It specifies the edge rank of the same edge type. The data type is int. If not specified, the default value is 0. You can insert many edges with the same edge type, source vertex, and destination vertex by using different rank values.\n<prop_value_list> must provide the value list according to <prop_name_list>. If the property values do not match the data type in the edge type, an error is returned. When the NOT NULL constraint is set for a given property, an error is returned if no property is given. When the default value for a property is NULL, you can omit to specify the property value. For details, see CREATE EDGE.\nExamples\n# The following example creates edge type e1 with no property and inserts an edge from vertex \"10\" to vertex \"11\" with no property.\nnebula> CREATE EDGE IF NOT EXISTS e1();                 \nnebula> INSERT EDGE e1 () VALUES \"10\"->\"11\":();  \n# The following example inserts an edge from vertex \"10\" to vertex \"11\" with no property. The edge rank is 1.\nnebula> INSERT EDGE e1 () VALUES \"10\"->\"11\"@1:(); \nnebula> CREATE EDGE IF NOT EXISTS e2 (name string, age int); \nnebula> INSERT EDGE e2 (name, age) VALUES \"11\"->\"13\":(\"n1\", 1);\n# The following example creates edge type e2 with two properties.\nnebula> INSERT EDGE e2 (name, age) VALUES \\\n        \"12\"->\"13\":(\"n1\", 1), \"13\"->\"14\":(\"n2\", 2); \n# In the following example, the insertion fails because \"a13\" is not int.\nnebula> INSERT EDGE e2 (name, age) VALUES \"11\"->\"13\":(\"n1\", \"a13\");\nAn edge can be inserted/written with property values multiple times. Only the last written values can be read.\nThe following examples insert edge e2 with the new values for multiple times.\nnebula> INSERT EDGE e2 (name, age) VALUES \"11\"->\"13\":(\"n1\", 12);\nnebula> INSERT EDGE e2 (name, age) VALUES \"11\"->\"13\":(\"n1\", 13);\nnebula> INSERT EDGE e2 (name, age) VALUES \"11\"->\"13\":(\"n1\", 14);\nnebula> FETCH PROP ON e2 \"11\"->\"13\" YIELD edge AS e;\nIf you insert an edge that already exists with IF NOT EXISTS, there will be no modification.\n# The following example inserts edge e2 from vertex \"14\" to vertex \"15\".\nnebula> INSERT EDGE e2 (name, age) VALUES \"14\"->\"15\"@1:(\"n1\", 12);\n# The following example alters the edge with IF NOT EXISTS. But there will be no alteration because edge e2 already exists.\nnebula> INSERT EDGE IF NOT EXISTS e2 (name, age) VALUES \"14\"->\"15\"@1:(\"n2\", 13);\nnebula> FETCH PROP ON e2 \"14\"->\"15\"@1 YIELD edge AS e;",
    "url": "13.edge-statements/1.insert-edge/",
    "type": "doc"
  },
  {
    "title": "DELETE EDGE",
    "content": "The DELETE EDGE statement deletes one edge or multiple edges at a time. You can use DELETE EDGE together with pipe operators. For more information, see PIPE OPERATORS.\nTo delete all the outgoing edges for a vertex, please delete the vertex. For more information, see DELETE VERTEX.\nSyntax\nDELETE EDGE <edge_type> <src_vid> -> <dst_vid>[@<rank>] [, <src_vid> -> <dst_vid>[@<rank>] ...]\nExamples\nnebula> DELETE EDGE serve \"player100\" -> \"team204\"@0;\nThe following example shows that you can use DELETE EDGE together with pipe operators to delete edges that meet the conditions.\nnebula> GO FROM \"player100\" OVER follow \\\n        WHERE dst(edge) == \"player101\" \\\n        YIELD src(edge) AS src, dst(edge) AS dst, rank(edge) AS rank \\\n        | DELETE EDGE follow $-.src->$-.dst @ $-.rank;",
    "url": "13.edge-statements/4.delete-edge/",
    "type": "doc"
  },
  {
    "title": "UPDATE EDGE",
    "content": "The UPDATE EDGE statement updates properties on an edge.\nIn NebulaGraph, UPDATE EDGE supports compare-and-swap (CAS).\nSyntax\nUPDATE EDGE ON <edge_type>\n<src_vid> -> <dst_vid> [@<rank>]\nSET <update_prop>\n[WHEN <condition>]\n[YIELD <output>]\nParameter\nRequired\nDescription\nExample\nON <edge_type>\nYes\nSpecifies the edge type. The properties to be updated must be on this edge type.\nON serve\n<src_vid>\nYes\nSpecifies the source vertex ID of the edge.\n\"player100\"\n<dst_vid>\nYes\nSpecifies the destination vertex ID of the edge.\n\"team204\"\n<rank>\nNo\nSpecifies the rank of the edge.  The data type is int.\n10\nSET <update_prop>\nYes\nSpecifies the properties to be updated and how they will be updated.\nSET start_year = start_year +1\nWHEN <condition>\nNo\nSpecifies the filter conditions. If <condition> evaluates to false, the SET clause does not take effect.\nWHEN end_year < 2010\nYIELD <output>\nNo\nSpecifies the output format of the statement.\nYIELD start_year AS Start_Year\nExample\nThe following example checks the properties of the edge with the GO statement.\nnebula> GO FROM \"player100\" \\\n        OVER serve \\\n        YIELD properties(edge).start_year, properties(edge).end_year;\nThe following example updates the start_year property and returns the end_year and the new start_year.\nnebula> UPDATE EDGE on serve \"player100\" -> \"team204\"@0 \\\n        SET start_year = start_year + 1 \\\n        WHEN end_year > 2010 \\\n        YIELD start_year, end_year;",
    "url": "13.edge-statements/2.update-edge/",
    "type": "doc"
  },
  {
    "title": "UPSERT EDGE",
    "content": "The UPSERT statement is a combination of UPDATE and INSERT. You can use UPSERT EDGE to update the properties of an edge if it exists or insert a new edge if it does not exist.\nThe performance of UPSERT is much lower than that of INSERT because UPSERT is a read-modify-write serialization operation at the partition level.\nSyntax\nUPSERT EDGE ON <edge_type>\n<src_vid> -> <dst_vid> [@rank]\nSET <update_prop>\n[WHEN <condition>]\n[YIELD <properties>]\nParameter\nRequired\nDescription\nExample\nON <edge_type>\nYes\nSpecifies the edge type. The properties to be updated must be on this edge type.\nON serve\n<src_vid>\nYes\nSpecifies the source vertex ID of the edge.\n\"player100\"\n<dst_vid>\nYes\nSpecifies the destination vertex ID of the edge.\n\"team204\"\n<rank>\nNo\nSpecifies the rank of the edge.\n10\nSET <update_prop>\nYes\nSpecifies the properties to be updated and how they will be updated.\nSET start_year = start_year +1\nWHEN <condition>\nNo\nSpecifies the filter conditions.\nWHEN end_year < 2010\nYIELD <output>\nNo\nSpecifies the output format of the statement.\nYIELD start_year AS Start_Year\nInsert an edge if it does not exist\nIf an edge does not exist, it is created no matter the conditions in the WHEN clause are met or not, and the SET clause takes effect. The property values of the new edge depend on:\nHow the SET clause is defined.\nWhether the property has a default value.\nFor example, if:\nThe edge to be inserted will have properties start_year and end_year based on the edge type serve.\nThe SET clause specifies that end_year = 2021.\nThen the property values in different cases are listed as follows:\nAre WHEN conditions met\nIf properties have default values\nValue of start_year\nValue of end_year\nYes\nYes\nThe default value\n2021\nYes\nNo\nNULL\n2021\nNo\nYes\nThe default value\n2021\nNo\nNo\nNULL\n2021\nHere are some examples:\n// This example checks if the following three vertices have any outgoing serve edge. The result \"Empty set\" indicates that such an edge does not exist.\nnebula> GO FROM \"player666\", \"player667\", \"player668\" \\\n        OVER serve \\\n        YIELD properties(edge).start_year, properties(edge).end_year;\nEmpty set\nnebula> UPSERT EDGE on serve \\\n        \"player666\" -> \"team200\"@0 \\\n        SET end_year = 2021 \\\n        WHEN end_year == 2010 \\\n        YIELD start_year, end_year;\nnebula> UPSERT EDGE on serve \\\n        \"player666\" -> \"team200\"@0 \\\n        SET end_year = 2022 \\\n        WHEN end_year == 2010 \\\n        YIELD start_year, end_year;\nnebula> UPSERT EDGE on serve \\\n        \"player667\" -> \"team200\"@0 \\\n        SET end_year = 2022 \\\n        YIELD start_year, end_year;\nnebula> UPSERT EDGE on serve \\\n        \"player668\" -> \"team200\"@0 \\\n        SET start_year = 2000, end_year = end_year + 1 \\\n        YIELD start_year, end_year;\nIn the last query of the preceding example, since end_year has no default value, when the edge is created, end_year is NULL, and end_year = end_year + 1 does not take effect. But if end_year has a default value, end_year = end_year + 1 will take effect. For example:\nnebula> CREATE EDGE IF NOT EXISTS serve_with_default(start_year int, end_year int DEFAULT 2010);\nExecution succeeded\nnebula> UPSERT EDGE on serve_with_default \\\n        \"player668\" -> \"team200\" \\\n        SET end_year = end_year + 1 \\\n        YIELD start_year, end_year;\nUpdate an edge if it exists\nIf the edge exists and the WHEN conditions are met, the edge is updated.\nnebula> MATCH (v:player{name:\"Ben Simmons\"})-[e:serve]-(v2) \\\n        RETURN e;\nnebula> UPSERT EDGE on serve \\\n        \"player149\" -> \"team219\" \\\n        SET end_year = end_year + 1 \\\n        WHEN start_year == 2016 \\\n        YIELD start_year, end_year;\nIf the edge exists and the WHEN conditions are not met, the update does not take effect.\nnebula> MATCH (v:player{name:\"Ben Simmons\"})-[e:serve]-(v2) \\\n        RETURN e;\nnebula> UPSERT EDGE on serve \\\n        \"player149\" -> \"team219\" \\\n        SET end_year = end_year + 1 \\\n        WHEN start_year != 2016 \\\n        YIELD start_year, end_year;",
    "url": "13.edge-statements/3.upsert-edge/",
    "type": "doc"
  },
  {
    "title": "Index overview",
    "content": "Indexes are built to fast process graph queries. Nebula Graph supports two kinds of indexes: native indexes and full-text indexes. This topic introduces the index types and helps choose the right index.\nUsage Instructions\nIndexes can improve query performance but may reduce write performance.\nAn index is a prerequisite for locating data when executing a LOOKUPstatement. If there is no index, an error will be reported when executing the LOOKUP statement.\nWhen using an index, NebulaGraph will automatically select the most optimal index.\nIndexes with high selectivity, that is, when the ratio of the number of records with unique values in the index column to the total number of records is high (for example, the ratio for ID numbers is 1), can significantly improve query performance. For indexes with low selectivity (such as country), query performance might not experience a substantial improvement.\nNative indexes\nNative indexes allow querying data based on a given property. Features are as follows.\nThere are two kinds of native indexes: tag index and edge type index.\nNative indexes must be updated manually. You can use the REBUILD INDEX statement to update native indexes.\nNative indexes support indexing multiple properties on a tag or an edge type (composite indexes), but do not support indexing across multiple tags or edge types.\nOperations on native indexes\nCREATE INDEX\nSHOW CREATE INDEX\nSHOW INDEXES\nDESCRIBE INDEX\nREBUILD INDEX\nSHOW INDEX STATUS\nDROP INDEX\nLOOKUP\nMATCH\nFull-text indexes\nFull-text indexes are used to do prefix, wildcard, regexp, and fuzzy search on a string property. Features are as follows.\nFull-text indexes allow indexing just one property.\nFull-text indexes do not support logical operations such as AND, OR, and NOT.\nNull values\nIndexes do not support indexing null values.\nRange queries\nIn addition to querying single results from native indexes, you can also do range queries. Not all the native indexes support range queries. You can only do range searches for numeric, date, and time type properties.",
    "url": "14.native-index-statements/",
    "type": "doc"
  },
  {
    "title": "CREATE INDEX",
    "content": "Prerequisites\nBefore you create an index, make sure that the relative tag or edge type is created. For how to create tags or edge types, see CREATE TAG and CREATE EDGE.\nFor how to create full-text indexes, see Deploy full-text index.\nMust-read for using indexes\nThe concept and using restrictions of indexes are comparatively complex. Before you use indexes, you must read the following sections carefully.\nYou can use CREATE INDEX to add native indexes for the existing tags, edge types, or properties. They are usually called as tag indexes, edge type indexes, and property indexes.\nTag indexes and edge type indexes apply to queries related to the tag and the edge type, but do not apply to queries that are based on certain properties on the tag. For example, you can use LOOKUP to retrieve all the vertices with the tag player.\nProperty indexes apply to property-based queries. For example, you can use the age property to retrieve the VID of all vertices that meet age == 19.\nIf a property index i_TA is created for the property A of the tag T and i_T for the tag T, the indexes can be replaced as follows (the same for edge type indexes):\nThe query engine can use i_TA to replace i_T.\nIn the MATCH and LOOKUP statements, i_T may replace i_TA for querying properties.\nAlthough the same results can be obtained by using alternative indexes for queries, the query performance varies according to the selected index.\nSteps\nIf you must use indexes, we suggest that you:\nImport the data into NebulaGraph.\nCreate indexes.\nRebuild indexes.\nAfter the index is created and the data is imported, you can use LOOKUP or MATCH to retrieve the data. You do not need to specify which indexes to use in a query, NebulaGraph figures that out by itself.\nSyntax\nCREATE {TAG | EDGE} INDEX [IF NOT EXISTS] <index_name> ON {<tag_name> | <edge_name>} ([<prop_name_list>]) [COMMENT '<comment>'];\nParameter\nDescription\nTAG | EDGE\nSpecifies the index type that you want to create.\nIF NOT EXISTS\nDetects if the index that you want to create exists. If it does not exist, a new one will be created.\n<index_name>\nThe name of the index. It must be unique in a graph space. A recommended way of naming is i_tagName_propName. Index names cannot start with a number. They supports 1 to 4 bytes UTF-8 encoded characters, such as English letters (case-sensitive), numbers, and Chinese characters, but does not support special characters except underscores. To use special characters, reserved keywords, or starting with a number, quote them with backticks. For more information, see Keywords and reserved words.Note: If you name an index in Chinese and encounter a SyntaxError, you need to quote the Chinese characters with backticks (`).\n<tag_name> | <edge_name>\nSpecifies the name of the tag or edge associated with the index.\n<prop_name_list>\nTo index a variable-length string property, you must use prop_name(length) to specify the index length. To index a tag or an edge type, ignore the prop_name_list.\nCOMMENT\nThe remarks of the index. The maximum length is 256 bytes. By default, there will be no comments on an index.\nCreate tag/edge type indexes\nnebula> CREATE TAG INDEX IF NOT EXISTS player_index on player();\nnebula> CREATE EDGE INDEX IF NOT EXISTS follow_index on follow();\nAfter indexing a tag or an edge type, you can use the LOOKUP statement to retrieve the VID of all vertices with the tag, or the source vertex ID, destination vertex ID, and ranks of all edges with the edge type. For more information, see LOOKUP.\nCreate single-property indexes\nnebula> CREATE TAG INDEX IF NOT EXISTS player_index_0 on player(name(10));\nThe preceding example creates an index for the name property on all vertices carrying the player tag. This example creates an index using the first 10 characters of the name property.\n# To index a variable-length string property, you need to specify the index length.\nnebula> CREATE TAG IF NOT EXISTS var_string(p1 string);\nnebula> CREATE TAG INDEX IF NOT EXISTS var ON var_string(p1(10));\n# To index a fixed-length string property, you do not need to specify the index length.\nnebula> CREATE TAG IF NOT EXISTS fix_string(p1 FIXED_STRING(10));\nnebula> CREATE TAG INDEX IF NOT EXISTS fix ON fix_string(p1);\nnebula> CREATE EDGE INDEX IF NOT EXISTS follow_index_0 on follow(degree);\nCreate composite property indexes\nAn index on multiple properties on a tag (or an edge type) is called a composite property index.\nnebula> CREATE TAG INDEX IF NOT EXISTS player_index_1 on player(name(10), age);",
    "url": "14.native-index-statements/1.create-native-index/",
    "type": "doc"
  },
  {
    "title": "SHOW INDEXES",
    "content": "SHOW INDEXES shows the defined tag or edge type indexes names in the current graph space.\nSyntax\nSHOW {TAG | EDGE} INDEXES\nExamples\nnebula> SHOW TAG INDEXES;\nnebula> SHOW EDGE INDEXES;",
    "url": "14.native-index-statements/2.show-native-indexes/",
    "type": "doc"
  },
  {
    "title": "SHOW CREATE INDEX",
    "content": "SHOW CREATE INDEX shows the statement used when creating a tag or an edge type. It contains detailed information about the index, such as its associated properties.\nSyntax\nSHOW CREATE {TAG | EDGE} INDEX <index_name>;\nExamples\nYou can run SHOW TAG INDEXES to list all tag indexes, and then use SHOW CREATE TAG INDEX to show the information about the creation of the specified index.\nnebula> SHOW TAG INDEXES;\nnebula> SHOW CREATE TAG INDEX player_index_1;\nEdge indexes can be queried through a similar approach.\nnebula> SHOW EDGE INDEXES;\nnebula> SHOW CREATE EDGE INDEX follow_index;",
    "url": "14.native-index-statements/2.1.show-create-index/",
    "type": "doc"
  },
  {
    "title": "DESCRIBE INDEX",
    "content": "DESCRIBE INDEX can get the information about the index with a given name, including the property name (Field) and the property type (Type) of the index.\nSyntax\nDESCRIBE {TAG | EDGE} INDEX <index_name>;\nExamples\nnebula> DESCRIBE TAG INDEX player_index_0;\nnebula> DESCRIBE TAG INDEX player_index_1;",
    "url": "14.native-index-statements/3.describe-native-index/",
    "type": "doc"
  },
  {
    "title": "REBUILD INDEX",
    "content": "You can use REBUILD INDEX to rebuild the created tag or edge type index. For details on how to create an index, see CREATE INDEX.\nSyntax\nREBUILD {TAG | EDGE} INDEX [<index_name_list>];\n<index_name_list>::=\n    [index_name [, index_name] ...]\nMultiple indexes are permitted in a single REBUILD statement, separated by commas. When the index name is not specified, all tag or edge indexes are rebuilt.\nAfter the rebuilding is complete, you can use the SHOW {TAG | EDGE} INDEX STATUS command to check if the index is successfully rebuilt. For details on index status, see SHOW INDEX STATUS.\nExamples\nnebula> CREATE TAG IF NOT EXISTS person(name string, age int, gender string, email string);\nnebula> CREATE TAG INDEX IF NOT EXISTS single_person_index ON person(name(10));\n# The following example rebuilds an index and returns the job ID.\nnebula> REBUILD TAG INDEX single_person_index;\n# The following example checks the index status.\nnebula> SHOW TAG INDEX STATUS;\n# You can also use \"SHOW JOB <job_id>\" to check if the rebuilding process is complete.\nnebula> SHOW JOB 31;\nNebulaGraph creates a job to rebuild the index. The job ID is displayed in the preceding return message. To check if the rebuilding process is complete, use the SHOW JOB <job_id> statement. For more information, see SHOW JOB.",
    "url": "14.native-index-statements/4.rebuild-native-index/",
    "type": "doc"
  },
  {
    "title": "SHOW INDEX STATUS",
    "content": "SHOW INDEX STATUS returns the name of the created tag or edge type index and its status of job.\nThe index status includes:\nQUEUE: The job is in a queue.\nRUNNING: The job is running.\nFINISHED: The job is finished.\nFAILED: The job has failed.\nSTOPPED: The job has stopped.\nINVALID: The job is invalid.\nSyntax\nSHOW {TAG | EDGE} INDEX STATUS;\nExample\nnebula> SHOW TAG INDEX STATUS;",
    "url": "14.native-index-statements/5.show-native-index-status/",
    "type": "doc"
  },
  {
    "title": "DROP INDEX",
    "content": "DROP INDEX removes an existing index from the current graph space.\nPrerequisite\nRunning the DROP INDEX statement requires some privileges of DROP TAG INDEX and DROP EDGE INDEX in the given graph space. Otherwise, NebulaGraph throws an error.\nSyntax\nDROP {TAG | EDGE} INDEX [IF EXISTS] <index_name>;\nIF EXISTS: Detects whether the index that you want to drop exists. If it exists, it will be dropped.\nExample\nnebula> DROP TAG INDEX player_index_0;",
    "url": "14.native-index-statements/6.drop-native-index/",
    "type": "doc"
  },
  {
    "title": "Full-text indexes",
    "content": "NebulaGraph CommunityNebulaGraph Enterprise\nFull-text indexes are used to do prefix, wildcard, regexp, and fuzzy search on a string property.\nYou can use the WHERE clause to specify the search strings in LOOKUP statements.\nPrerequisite\nBefore using the full-text index, make sure that you have deployed a Elasticsearch cluster and a Listener cluster. For more information, see Deploy Elasticsearch and Deploy Listener.\nPrecaution\nBefore using the full-text index, make sure that you know the restrictions.\nNatural language full-text search\nA natural language search interprets the search string as a phrase in natural human language. The search is case-sensitive and by default prefixes the string with a match. For example, there are three vertices with the tag player. The tag player contains the property name. The name of these three vertices are Kevin Durant, Tim Duncan, and David Beckham. Now that the full-text index of player.name is established, only David Beckham will be queried when using the prefix search statement LOOKUP ON player WHERE PREFIX(player.name,\"D\");.\nSyntax\nCreate full-text indexes\nCREATE FULLTEXT {TAG | EDGE} INDEX <index_name> ON {<tag_name> | <edge_name>} ([<prop_name>]);\nShow full-text indexes\nSHOW FULLTEXT INDEXES;\nRebuild full-text indexes\nREBUILD FULLTEXT INDEX;\nDrop full-text indexes\nDROP FULLTEXT INDEX <index_name>;\nUse query options\nLOOKUP ON {<tag> | <edge_type>} WHERE <expression> [YIELD <return_list>];\n<expression> ::=\n    PREFIX | WILDCARD | REGEXP | FUZZY\n<return_list>\n    <prop_name> [AS <prop_alias>] [, <prop_name> [AS <prop_alias>] ...]\nPREFIX(schema_name.prop_name, prefix_string, row_limit, timeout)\nWILDCARD(schema_name.prop_name, wildcard_string, row_limit, timeout)\nREGEXP(schema_name.prop_name, regexp_string, row_limit, timeout)\nFUZZY(schema_name.prop_name, fuzzy_string, fuzziness, operator, row_limit, timeout)\nfuzziness (optional): Maximum edit distance allowed for matching. The default value is AUTO. For other valid values and more information, see Elasticsearch document.\noperator (optional): Boolean logic used to interpret the text. Valid values are OR (default) and AND.\nrow_limit (optional): Specifies the number of rows to return. The default value is 100.\ntimeout (optional): Specifies the timeout time. The default value is 200ms.\nExamples\n// This example creates the graph space.\nnebula> CREATE SPACE IF NOT EXISTS basketballplayer (partition_num=3,replica_factor=1, vid_type=fixed_string(30));\n// This example signs in the text service.\nnebula> SIGN IN TEXT SERVICE (127.0.0.1:9200, HTTP);\n// This example checks the text service status.\nnebula> SHOW TEXT SEARCH CLIENTS;\n// This example switches the graph space.\nnebula> USE basketballplayer;\n// This example adds the listener to the NebulaGraph cluster.\nnebula> ADD LISTENER ELASTICSEARCH 192.168.8.5:9789;\n// This example checks the listener status. When the status is `Online`, the listener is ready.\nnebula> SHOW LISTENER;\n// This example creates the tag.\nnebula> CREATE TAG IF NOT EXISTS player(name string, age int);\n// This example creates the full-text index. The index name starts with \"nebula_\".\nnebula> CREATE FULLTEXT TAG INDEX nebula_index_1 ON player(name);\n// This example rebuilds the full-text index.\nnebula> REBUILD FULLTEXT INDEX;\n// This example shows the full-text index.\nnebula> SHOW FULLTEXT INDEXES;\n// This example inserts the test data.\nnebula> INSERT VERTEX player(name, age) VALUES \\\n  \"Russell Westbrook\": (\"Russell Westbrook\", 30), \\\n  \"Chris Paul\": (\"Chris Paul\", 33),\\\n  \"Boris Diaw\": (\"Boris Diaw\", 36),\\\n  \"David West\": (\"David West\", 38),\\\n  \"Danny Green\": (\"Danny Green\", 31),\\\n  \"Tim Duncan\": (\"Tim Duncan\", 42),\\\n  \"James Harden\": (\"James Harden\", 29),\\\n  \"Tony Parker\": (\"Tony Parker\", 36),\\\n  \"Aron Baynes\": (\"Aron Baynes\", 32),\\\n  \"Ben Simmons\": (\"Ben Simmons\", 22),\\\n  \"Blake Griffin\": (\"Blake Griffin\", 30);\n// These examples run test queries.\nnebula> LOOKUP ON player WHERE PREFIX(player.name, \"B\") YIELD id(vertex);\nnebula> LOOKUP ON player WHERE WILDCARD(player.name, \"*ri*\") YIELD player.name, player.age;\nnebula> LOOKUP ON player WHERE WILDCARD(player.name, \"*ri*\") YIELD player.name, player.age | YIELD count(*);\nnebula> LOOKUP ON player WHERE REGEXP(player.name, \"R.*\") YIELD player.name, player.age;\nnebula> LOOKUP ON player WHERE REGEXP(player.name, \".*\") YIELD id(vertex);\n...\nnebula> LOOKUP ON player WHERE FUZZY(player.name, \"Tim Dunncan\", AUTO, OR) YIELD player.name;\n// This example drops the full-text index.\nnebula> DROP FULLTEXT INDEX nebula_index_1;\nFull-text indexes are used to do prefix, wildcard, regexp, and fuzzy search on a string property.\nYou can use the WHERE clause to specify the search strings in LOOKUP statements.\nPrerequisite\nBefore using the full-text index, make sure that you have deployed a Elasticsearch cluster and a Listener cluster. For more information, see Deploy Elasticsearch and Deploy Listener.\nPrecaution\nBefore using the full-text index, make sure that you know the restrictions.\nFull Text Queries\nFull-text queries enable you to search for parsed text fields, using a parser with strict syntax to return content based on the query string provided. For details, see Query string query.\nSyntax\nCreate full-text indexes\nCREATE FULLTEXT {TAG | EDGE} INDEX <index_name> ON {<tag_name> | <edge_name>} (<prop_name> [,<prop_name>]...) [ANALYZER=\"<analyzer_name>\"];\nComposite indexes with multiple properties are supported when creating full-text indexes.\n<analyzer_name> is the name of the analyzer. The default value is standard. To use other analyzers (e.g. IK Analysis), you need to make sure that the corresponding analyzer is installed in Elasticsearch in advance.\nShow full-text indexes\nSHOW FULLTEXT INDEXES;\nRebuild full-text indexes\nREBUILD FULLTEXT INDEX;\nDrop full-text indexes\nDROP FULLTEXT INDEX <index_name>;\nUse query options\nLOOKUP ON {<tag> | <edge_type>} WHERE ES_QUERY(<index_name>, \"<text>\") YIELD <return_list> [| LIMIT [<offset>,] <number_rows>];\n<return_list>\n    <prop_name> [AS <prop_alias>] [, <prop_name> [AS <prop_alias>] ...] [, id(vertex)  [AS <prop_alias>]] [, score() AS <score_alias>]\nindex_name: The name of the full-text index.\ntext: Search conditions. For supported syntax, see Query string syntax.\nscore(): The score calculated by doing N degree expansion for the eligible vertices. The default value is 1.0. The higher the score, the higher the degree of match. The return value is sorted by default from highest to lowest score. For details, see Search and Scoring in Lucene.\nExamples\n// This example creates the graph space.\nnebula> CREATE SPACE IF NOT EXISTS basketballplayer (partition_num=3,replica_factor=1, vid_type=fixed_string(30));\n// This example signs in the text service.\nnebula> SIGN IN TEXT SERVICE (192.168.8.100:9200, HTTP);\n// This example checks the text service status.\nnebula> SHOW TEXT SEARCH CLIENTS;\n// This example switches the graph space.\nnebula> USE basketballplayer;\n// This example adds the listener to the NebulaGraph cluster.\nnebula> ADD LISTENER ELASTICSEARCH 192.168.8.100:9789;\n// This example checks the listener status. When the status is `Online`, the listener is ready.\nnebula> SHOW LISTENER;\n// This example creates the tag.\nnebula> CREATE TAG IF NOT EXISTS player(name string, city string);\n// This example creates a single-attribute full-text index.\nnebula> CREATE FULLTEXT TAG INDEX fulltext_index_1 ON player(name) ANALYZER=\"standard\";\n// This example creates a multi-attribute full-text indexe.\nnebula> CREATE FULLTEXT TAG INDEX fulltext_index_2 ON player(name,city) ANALYZER=\"standard\";\n// This example rebuilds the full-text index.\nnebula> REBUILD FULLTEXT INDEX;\n// This example shows the full-text index.\nnebula> SHOW FULLTEXT INDEXES;\n// This example inserts the test data.\nnebula> INSERT VERTEX player(name, city) VALUES \\\n  \"Russell Westbrook\": (\"Russell Westbrook\", \"Los Angeles\"), \\\n  \"Chris Paul\": (\"Chris Paul\", \"Houston\"),\\\n  \"Boris Diaw\": (\"Boris Diaw\", \"Houston\"),\\\n  \"David West\": (\"David West\", \"Philadelphia\"),\\\n  \"Danny Green\": (\"Danny Green\", \"Philadelphia\"),\\\n  \"Tim Duncan\": (\"Tim Duncan\", \"New York\"),\\\n  \"James Harden\": (\"James Harden\", \"New York\"),\\\n  \"Tony Parker\": (\"Tony Parker\", \"Chicago\"),\\\n  \"Aron Baynes\": (\"Aron Baynes\", \"Chicago\"),\\\n  \"Ben Simmons\": (\"Ben Simmons\", \"Phoenix\"),\\\n  \"Blake Griffin\": (\"Blake Griffin\", \"Phoenix\");\n// These examples run test queries.\nnebula> LOOKUP ON player WHERE ES_QUERY(fulltext_index_1,\"Chris\") YIELD id(vertex);\nnebula> LOOKUP ON player WHERE ES_QUERY(fulltext_index_1,\"Harden\") YIELD properties(vertex);\nnebula> LOOKUP ON player WHERE ES_QUERY(fulltext_index_1,\"Da*\") YIELD properties(vertex);\nnebula> LOOKUP ON player WHERE ES_QUERY(fulltext_index_1,\"*b*\") YIELD id(vertex);\nnebula> LOOKUP ON player WHERE ES_QUERY(fulltext_index_1,\"*b*\") YIELD id(vertex) | LIMIT 2,3;\nnebula> LOOKUP ON player WHERE ES_QUERY(fulltext_index_1,\"*b*\") YIELD id(vertex) | YIELD count(*);\nnebula> LOOKUP ON player WHERE ES_QUERY(fulltext_index_1,\"*b*\") YIELD id(vertex), score() AS score;\n// For documents containing a word `b`, its score will be multiplied by a weighting factor of 4, while for documents containing a word `c`, the default weighting factor of 1 is used.\nnebula> LOOKUP ON player WHERE ES_QUERY(fulltext_index_1,\"*b*^4 OR *c*\") YIELD id(vertex), score() AS score;\n// When using a multi-attribute full-text index query, the conditions are matched within all properties of the index.\nnebula> LOOKUP ON player WHERE ES_QUERY(fulltext_index_2,\"*h*\") YIELD properties(vertex);\n// When using multi-attribute full-text index queries, you can specify different text for different properties for the query.\nnebula> LOOKUP ON player WHERE ES_QUERY(fulltext_index_2,\"name:*b* AND city:Houston\") YIELD properties(vertex);\n// Delete single-attribute full-text index.\nnebula> DROP FULLTEXT INDEX fulltext_index_1;",
    "url": "15.full-text-index-statements/1.search-with-text-based-index/",
    "type": "doc"
  },
  {
    "title": "GET SUBGRAPH",
    "content": "The GET SUBGRAPH statement returns a subgraph that is generated by traversing a graph starting from a specified vertex. GET SUBGRAPH statements allow you to specify the number of steps and the type or direction of edges during the traversal.\nSyntax\nGET SUBGRAPH [WITH PROP] [<step_count> {STEP|STEPS}] FROM {<vid>, <vid>...}\n[{IN | OUT | BOTH} <edge_type>, <edge_type>...]\n[WHERE <expression> [AND <expression> ...]]\nYIELD {[VERTICES AS <vertex_alias>] [,EDGES AS <edge_alias>]};\nWITH PROP shows the properties. If not specified, the properties will be hidden.\nstep_count specifies the number of hops from the source vertices and returns the subgraph from 0 to step_count hops. It must be a non-negative integer. Its default value is 1.\nvid specifies the vertex IDs. \nedge_type specifies the edge type. You can use IN, OUT, and BOTH to specify the traversal direction of the edge type. The default is BOTH.\n<WHERE clause> specifies the filter conditions for the traversal, which can be used with the boolean operator AND.\nYIELD defines the output that needs to be returned. You can return only vertices or edges. A column alias must be set.\nLimitations\nWhile using the WHERE clause in a GET SUBGRAPH statement, note the following restrictions:\nOnly support the AND operator.\nOnly support filter destination vertex, the vertex format must be $$.tagName.propName.\nSupport filter edge, the edge format must be edge_type.propName.\nSupport math functions, aggregate functions, string functions, datetime functions, type conversion functions and general functions in list functions.\nNot support aggregate functions, schema-related functions, conditional expression, predicate functions, geography function and user-defined functions.\nExamples\nThe following graph is used as the sample.\nInsert the test data:\nnebula> CREATE SPACE IF NOT EXISTS subgraph(partition_num=15, replica_factor=1, vid_type=fixed_string(30));\nnebula> USE subgraph;\nnebula> CREATE TAG IF NOT EXISTS player(name string, age int);\nnebula> CREATE TAG IF NOT EXISTS team(name string);\nnebula> CREATE EDGE IF NOT EXISTS follow(degree int);\nnebula> CREATE EDGE IF NOT EXISTS serve(start_year int, end_year int);\nnebula> INSERT VERTEX player(name, age) VALUES \"player100\":(\"Tim Duncan\", 42);\nnebula> INSERT VERTEX player(name, age) VALUES \"player101\":(\"Tony Parker\", 36);\nnebula> INSERT VERTEX player(name, age) VALUES \"player102\":(\"LaMarcus Aldridge\", 33);\nnebula> INSERT VERTEX team(name) VALUES \"team203\":(\"Trail Blazers\"), \"team204\":(\"Spurs\");\nnebula> INSERT EDGE follow(degree) VALUES \"player101\" -> \"player100\":(95);\nnebula> INSERT EDGE follow(degree) VALUES \"player101\" -> \"player102\":(90);\nnebula> INSERT EDGE follow(degree) VALUES \"player102\" -> \"player100\":(75);\nnebula> INSERT EDGE serve(start_year, end_year) VALUES \"player101\" -> \"team204\":(1999, 2018),\"player102\" -> \"team203\":(2006,  2015);\nThis example goes one step from the vertex player101 over all edge types and gets the subgraph.nebula> GET SUBGRAPH 1 STEPS FROM \"player101\" YIELD VERTICES AS nodes, EDGES AS relationships;\nThe returned subgraph is as follows.\nThis example goes one step from the vertex player101 over incoming follow edges and gets the subgraph.nebula> GET SUBGRAPH 1 STEPS FROM \"player101\" IN follow YIELD VERTICES AS nodes, EDGES AS relationships;\nThere is no incoming follow edge to player101, so only the vertex player101 is returned.\nThis example goes one step from the vertex player101 over outgoing serve edges, gets the subgraph, and shows the property of the edge.nebula> GET SUBGRAPH WITH PROP 1 STEPS FROM \"player101\" OUT serve YIELD VERTICES AS nodes, EDGES AS relationships;\nThe returned subgraph is as follows.\nThis example goes two steps from the vertex player101 over follow edges, filters by degree > 90 and age > 30, and shows the properties of edges.nebula> GET SUBGRAPH WITH PROP 2 STEPS FROM \"player101\" \\\n    WHERE follow.degree > 90 AND $$.player.age > 30 \\\n    YIELD VERTICES AS nodes, EDGES AS relationships;\nFAQ\nWhy is the number of hops in the returned result greater than step_count?\nTo show the completeness of the subgraph, an additional hop is made on all vertices that meet the conditions. The following graph is used as the sample.\nThe returned paths of GET SUBGRAPH 1 STEPS FROM \"A\"; are A->B, B->A, and A->C. To show the completeness of the subgraph, an additional hop is made on all vertices that meet the conditions, namely B->C.\nThe returned path of GET SUBGRAPH 1 STEPS FROM \"A\" IN follow; is B->A. To show the completeness of the subgraph, an additional hop is made on all vertices that meet the conditions, namely A->B.\nIf you only query paths or vertices that meet the conditions, we suggest you use MATCH or GO. The example is as follows.\nnebula> MATCH p= (v:player) -- (v2) WHERE id(v)==\"A\" RETURN p;\nnebula> GO 1 STEPS FROM \"A\" OVER follow YIELD src(edge),dst(edge);\nWhy is the number of hops in the returned result lower than step_count?\nThe query stops when there is not enough subgraph data and will not return the null value.\nnebula> GET SUBGRAPH 100 STEPS FROM \"player101\" OUT follow YIELD VERTICES AS nodes, EDGES AS relationships;",
    "url": "16.subgraph-and-path/1.get-subgraph/",
    "type": "doc"
  },
  {
    "title": "FIND PATH",
    "content": "The FIND PATH statement finds the paths between the selected source vertices and destination vertices.\nSyntax\nFIND { SHORTEST | ALL | NOLOOP } PATH [WITH PROP] FROM <vertex_id_list> TO <vertex_id_list>\nOVER <edge_type_list> [REVERSELY | BIDIRECT] \n[<WHERE clause>] [UPTO <N> {STEP|STEPS}] \nYIELD path as <alias>\n[| ORDER BY $-.path] [| LIMIT <M>];\n<vertex_id_list> ::=\n    [vertex_id [, vertex_id] ...]\nSHORTEST finds the shortest path.\nALL finds all the paths.\nNOLOOP finds the paths without circles.\nWITH PROP shows properties of vertices and edges. If not specified, properties will be hidden.\n<vertex_id_list> is a list of vertex IDs separated with commas (,). It supports $- and $var.\n<edge_type_list> is a list of edge types separated with commas (,). * is all edge types.\nREVERSELY | BIDIRECT specifies the direction. REVERSELY is reverse graph traversal while BIDIRECT is bidirectional graph traversal.\n<WHERE clause> filters properties of edges.\n<N> is the maximum hop number of the path. The default value is 5.\n<M> specifies the maximum number of rows to return.\nLimitations\nWhen a list of source and/or destination vertex IDs are specified, the paths between any source vertices and the destination vertices will be returned.\nThere can be cycles when searching all paths.\nFIND PATH only supports filtering properties of edges with WHERE clauses. Filtering properties of vertices and functions are not supported for now.\nFIND PATH is a single-thread procedure, so it uses much memory.\nExamples\nA returned path is like (<vertex_id>)-[:<edge_type_name>@<rank>]->(<vertex_id).\nnebula> FIND SHORTEST PATH FROM \"player102\" TO \"team204\" OVER * YIELD path AS p;\nnebula> FIND SHORTEST PATH WITH PROP FROM \"team204\" TO \"player100\" OVER * REVERSELY YIELD path AS p;\nnebula> FIND ALL PATH FROM \"player100\" TO \"team204\" OVER * WHERE follow.degree is EMPTY or follow.degree >=0 YIELD path AS p;\nnebula> FIND NOLOOP PATH FROM \"player100\" TO \"team204\" OVER * YIELD path AS p;\nFAQ\nDoes it support the WHERE clause to achieve conditional filtering during graph traversal?\nFIND PATH only supports filtering properties of edges with WHERE clauses, such as WHERE follow.degree is EMPTY or follow.degree >=0.\nFiltering properties of vertices is not supported for now.",
    "url": "16.subgraph-and-path/2.find-path/",
    "type": "doc"
  },
  {
    "title": "EXPLAIN and PROFILE",
    "content": "EXPLAIN helps output the execution plan of an nGQL statement without executing the statement.\nPROFILE executes the statement, then outputs the execution plan as well as the execution profile. You can optimize the queries for better performance according to the execution plan and profile.\nExecution Plan\nThe execution plan is determined by the execution planner in the NebulaGraph query engine.\nThe execution planner processes the parsed nGQL statements into actions. An action is the smallest unit that can be executed. A typical action fetches all neighbors of a given vertex, gets the properties of an edge, and filters vertices or edges based on the given conditions. Each action is assigned to an operator that performs the action.\nFor example, a SHOW TAGS statement is processed into two actions and assigned to a Start operator and a ShowTags operator, while a more complex GO statement may be processed into more than 10 actions and assigned to 10 operators.\nSyntax\nEXPLAINEXPLAIN [format= {\"row\" | \"dot\" | \"tck\"}] <your_nGQL_statement>;\nPROFILEPROFILE [format= {\"row\" | \"dot\" | \"tck\"}] <your_nGQL_statement>;\nOutput formats\nThe output of an EXPLAIN or a PROFILE statement has three formats, the default row format, the dot format, and the tck format. You can use the format option to modify the output format. Omitting the format option indicates using the default row format.\nThe row format\nThe row format outputs the return message in a table as follows.\nEXPLAINnebula> EXPLAIN format=\"row\" SHOW TAGS;\nExecution succeeded (time spent 327/892 us)\nExecution Plan\n-----+----------+--------------+----------------+----------------------------------------------------------------------\n-----+----------+--------------+----------------+----------------------------------------------------------------------\n-----+----------+--------------+----------------+----------------------------------------------------------------------\n-----+----------+--------------+----------------+----------------------------------------------------------------------\nPROFILEnebula> PROFILE format=\"row\" SHOW TAGS;\nGot 2 rows (time spent 2038/2728 us)\nExecution Plan\n-----+----------+--------------+----------------------------------------------------+----------------------------------------------------------------------\n-----+----------+--------------+----------------------------------------------------+----------------------------------------------------------------------\n-----+----------+--------------+----------------------------------------------------+----------------------------------------------------------------------\n-----+----------+--------------+----------------------------------------------------+----------------------------------------------------------------------\nThe descriptions are as follows.\nParameter\nDescription\nid\nThe ID of the operator.\nname\nThe name of the operator.\ndependencies\nThe ID of the operator that the current operator depends on.\nprofiling data\nThe content of the execution profile. ver is the version of the operator. rows shows the number of rows to be output by the operator. execTime shows the execution time of action. totalTime is the sum of the execution time, the system scheduling time, and the queueing time.\noperator info\nThe detailed information of the operator.\nThe dot format\nYou can use the format=\"dot\" option to output the return message in the dot language, and then use Graphviz to generate a graph of the plan.\nnebula> EXPLAIN format=\"dot\" SHOW TAGS;\nExecution succeeded (time spent 161/665 us)\nExecution Plan\n---------------------------------------------------------------------------------------------------------------------------------------------  -------------\n  plan\n---------------------------------------------------------------------------------------------------------------------------------------------  -------------\n  digraph exec_plan {\n      rankdir=LR;\n      \"ShowTags_0\"[label=\"ShowTags_0|outputVar: \\[\\{\\\"colNames\\\":\\[\\],\\\"name\\\":\\\"__ShowTags_0\\\",\\\"type\\\":\\\"DATASET\\\"\\}\\]\\l|inputVar:\\l\",   shape=Mrecord];\n      \"Start_2\"->\"ShowTags_0\";\n      \"Start_2\"[label=\"Start_2|outputVar: \\[\\{\\\"colNames\\\":\\[\\],\\\"name\\\":\\\"__Start_2\\\",\\\"type\\\":\\\"DATASET\\\"\\}\\]\\l|inputVar: \\l\",   shape=Mrecord];\n---------------------------------------------------------------------------------------------------------------------------------------------  -------------\nThe Graphviz graph transformed from the above DOT statement is as follows.\nThe tck format\nThe tck format is similar to a table, but without borders and dividing lines between rows. You can use the results as test cases for unit testing. \nFor information on tck format test cases, see TCK cases.\nEXPLAINnebula> EXPLAIN format=\"tck\" FETCH PROP ON player \"player_1\",\"player_2\",\"player_3\" YIELD properties(vertex).name as name, properties(vertex).age as age;\nExecution succeeded (time spent 261µs/613.718µs)\nExecution Plan (optimize time 28 us)\nWed, 22 Mar 2023 23:15:52 CST\nPROFILEnebula> PROFILE format=\"tck\" FETCH PROP ON player \"player_1\",\"player_2\",\"player_3\" YIELD properties(vertex).name as name, properties(vertex).age as age;\nGot 3 rows (time spent 1.474ms/2.19677ms)\nExecution Plan (optimize time 41 us)\nWed, 22 Mar 2023 23:16:13 CST",
    "url": "17.query-tuning-statements/1.explain-and-profile/",
    "type": "doc"
  },
  {
    "title": "Kill queries",
    "content": "KILL QUERY can terminate the query being executed, and is often used to terminate slow queries.\nSyntax\nKILL QUERY (session=<session_id>, plan=<plan_id>);\nsession_id: The ID of the session.\nplan_id: The ID of the execution plan.\nThe ID of the session and the ID of the execution plan can uniquely determine a query. Both can be obtained through the SHOW QUERIES statement.\nExamples\nThis example executes KILL QUERY in one session to terminate the query in another session.\nnebula> KILL QUERY(SESSION=1625553545984255,PLAN=163);\nThe query will be terminated and the following information will be returned.\n[ERROR (-1005)]: ExecutionPlanId[1001] does not exist in current Session.",
    "url": "17.query-tuning-statements/6.kill-query/",
    "type": "doc"
  },
  {
    "title": "Kill sessions",
    "content": "The KILL SESSION command is to terminate running sessions.\nSyntax\nYou can run the KILL SESSION command to terminate one or multiple sessions. The syntax is as follows:\nTo terminate one session\nKILL {SESSION|SESSIONS} <SessionId>\n{SESSION|SESSIONS}: SESSION or SESSIONS, both are supported. \n<SessionId>: Specifies the ID of one session. You can run the SHOW SESSIONS command to view the IDs of sessions.\nTo terminate multiple sessions\nSHOW SESSIONS \n| YIELD $-.SessionId AS sid [WHERE <filter_clause>]\n| KILL {SESSION|SESSIONS} $-.sid\n[WHERE <filter_clause>]：\nOptional, the WHERE clause is used to filter sessions. <filter_expression> specifies a session filtering expression, for example, WHERE $-.CreateTime < datetime(\"2022-12-14T18:00:00\"). If the WHERE clause is not specified, all sessions are terminated.\nFiltering conditions in a WHERE clause include: SessionId, UserName, SpaceName, CreateTime, UpdateTime, GraphAddr, Timezone, and ClientIp. You can run the SHOW SESSIONS command to view descriptions of these conditions.\n{SESSION|SESSIONS}: SESSION or SESSIONS, both are supported.\nExamples\nTo terminate one session\nnebula> KILL SESSION 1672887983842984 \nTo terminate multiple sessions\nTerminate all sessions whose creation time is less than 2023-01-05T18:00:00.\nnebula> SHOW SESSIONS | YIELD $-.SessionId AS sid WHERE $-.CreateTime < datetime(\"2023-01-05T18:00:00\") | KILL SESSIONS $-.sid\nTerminates the two sessions with the earliest creation times.\nnebula> SHOW SESSIONS | YIELD $-.SessionId AS sid, $-.CreateTime as CreateTime | ORDER BY $-.CreateTime ASC | LIMIT 2 | KILL SESSIONS $-.sid\nTerminates all sessions created by the username session_user1.\nnebula> SHOW SESSIONS | YIELD $-.SessionId as sid WHERE $-.UserName == \"session_user1\" | KILL SESSIONS $-.sid\nTerminate all sessions.\nnebula> SHOW SESSIONS | YIELD $-.SessionId as sid | KILL SESSION $-.sid\n// Or\nnebula> SHOW SESSIONS | KILL SESSIONS $-.SessionId",
    "url": "17.query-tuning-statements/2.kill-session/",
    "type": "doc"
  },
  {
    "title": "Job manager and the JOB statements",
    "content": "The long-term tasks run by the Storage Service are called jobs, such as COMPACT, FLUSH, and STATS. These jobs can be time-consuming if the data amount in the graph space is large. The job manager helps you run, show, stop, and recover jobs.\nSUBMIT JOB BALANCE DATA\nThe SUBMIT JOB BALANCE DATA statement starts a job to balance the distribution of storage partitions in the current graph space. It returns the job ID.\nFor example:\nnebula> SUBMIT JOB BALANCE DATA;\nSUBMIT JOB BALANCE DATA REMOVE\nStarts a job to balance the distribution of storage partitions in the current graph space. The default port is 9779. It returns the job ID.\nFor example:\nnebula> SUBMIT JOB BALANCE DATA REMOVE 192.168.8.100:9779;\nSUBMIT JOB BALANCE LEADER\nStarts a job to balance the distribution of all the storage leaders in all graph spaces. It returns the job ID.\nFor example:\nnebula> SUBMIT JOB BALANCE LEADER;\nSUBMIT JOB COMPACT\nThe SUBMIT JOB COMPACT statement triggers the long-term RocksDB compact operation in the current graph space.\nFor more information about compact configuration, see Storage Service configuration.\nFor example:\nnebula> SUBMIT JOB COMPACT;\nSUBMIT JOB FLUSH\nThe SUBMIT JOB FLUSH statement writes the RocksDB memfile in the memory to the hard disk in the current graph space.\nFor example:\nnebula> SUBMIT JOB FLUSH;\nSUBMIT JOB STATS\nThe SUBMIT JOB STATS statement starts a job that makes the statistics of the current graph space. Once this job succeeds, you can use the SHOW STATS statement to list the statistics. For more information, see SHOW STATS.\nFor example:\nnebula> SUBMIT JOB STATS;\nSUBMIT JOB DOWNLOAD/INGEST\nThe SUBMIT JOB DOWNLOAD HDFS and SUBMIT JOB INGEST commands are used to import the SST file into NebulaGraph. For detail, see Import data from SST files.\nThe SUBMIT JOB DOWNLOAD HDFS command will download the SST file on the specified HDFS.\nThe SUBMIT JOB INGEST command will import the downloaded SST file into NebulaGraph.\nFor example:\nnebula> SUBMIT JOB DOWNLOAD HDFS \"hdfs://192.168.10.100:9000/sst\";\nnebula> SUBMIT JOB INGEST;\nSHOW JOB\nThe Meta Service parses a SUBMIT JOB request into multiple tasks and assigns them to the nebula-storaged processes. The SHOW JOB <job_id> statement shows the information about a specific job and all its tasks in the current graph space.\njob_id is returned when you run the SUBMIT JOB statement.\nFor example:\nnebula> SHOW JOB 9;\nThe descriptions are as follows.\nParameter\nDescription\nJob Id(TaskId)\nThe first row shows the job ID and the other rows show the task IDs and the last row shows the total number of job-related tasks.\nCommand(Dest)\nThe first row shows the command executed and the other rows show on which storaged processes the task is running. The last row shows the number of successful tasks related to the job.\nStatus\nShows the status of the job or task. The last row shows the number of failed tasks related to the job. For more information, see Job status.\nStart Time\nShows a timestamp indicating the time when the job or task enters the RUNNING phase. The last row shows the number of ongoing tasks related to the job.\nStop Time\nShows a timestamp indicating the time when the job or task gets FINISHED, FAILED, or STOPPED.\nError Code\nThe error code of job.\nJob status\nThe descriptions are as follows.\nStatus\nDescription\nQUEUE\nThe job or task is waiting in a queue. The Start Time is empty in this phase.\nRUNNING\nThe job or task is running. The Start Time shows the beginning time of this phase.\nFINISHED\nThe job or task is successfully finished. The Stop Time shows the time when the job or task enters this phase.\nFAILED\nThe job or task has failed. The Stop Time shows the time when the job or task enters this phase.\nSTOPPED\nThe job or task is stopped without running. The Stop Time shows the time when the job or task enters this phase.\nREMOVED\nThe job or task is removed.\nThe description of switching the status is described as follows.\nQueue -- running -- finished -- removed\n     \\          \\                /\n      \\          \\ -- failed -- /\n       \\          \\            /\n        \\ ---------- stopped -/\nSHOW JOBS\nThe SHOW JOBS statement lists all the unexpired jobs in the current graph space.\nThe default job expiration interval is one week. You can change it by modifying the job_expired_secs parameter of the Meta Service. For how to modify job_expired_secs, see Meta Service configuration.\nFor example:\nnebula> SHOW JOBS;\nSTOP JOB\nThe STOP JOB <job_id> statement stops jobs that are not finished in the current graph space.\nFor example:\nnebula> STOP JOB 22;\nRECOVER JOB\nThe RECOVER JOB [<job_id>] statement re-executes the jobs that status is FAILED or STOPPED in the current graph space and returns the number of recovered jobs. If <job_id> is not specified, re-execution is performed from the earliest job and the number of jobs that have been recovered is returned.\nFor example:\nnebula> RECOVER JOB;\nFAQ\nHow to troubleshoot job problems?\nThe SUBMIT JOB operations use the HTTP port. Please check if the HTTP ports on the machines where the Storage Service is running are working well. You can use the following command to debug.\ncurl \"http://{storaged-ip}:19779/admin?space={space_name}&op=compact\"",
    "url": "4.job-statements/",
    "type": "doc"
  }
]